<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming | 码工作坊]]></title>
  <link href="http://khotyn.github.com/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://khotyn.github.com/"/>
  <updated>2013-09-14T21:42:25+08:00</updated>
  <id>http://khotyn.github.com/</id>
  <author>
    <name><![CDATA[khotyn]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Spring 事务的传播特性]]></title>
    <link href="http://khotyn.github.com/blog/2013/09/14/spring-tx-propagation/"/>
    <updated>2013-09-14T18:06:00+08:00</updated>
    <id>http://khotyn.github.com/blog/2013/09/14/spring-tx-propagation</id>
    <content type="html"><![CDATA[<p>最近工作中涉及到了一个分布式事务的产品，这个产品是在 Spring 的事务上做的，我对其中涉及到的 Spring 的事务的传播特性不是很了解，所以今天花了一个下午的时间认真了解了一下，写了一堆的测试代码。</p>

<p>进入正题，Spring 的事务的传播特性分为以下的七种：</p>

<ul>
<li>PROPAGATION_REQUIRED</li>
<li>PROPAGATION_SUPPORTS</li>
<li>PROPAGATION_MANDATORY</li>
<li>PROPAGATION_REQUIRES_NEW</li>
<li>PROPAGATION_NOT_SUPPORTED</li>
<li>PROPAGATION_NEVER</li>
<li>PROPAGATION_NESTED</li>
</ul>


<p>下面一种种来解释：</p>

<h4>PROPAGATION_REQUIRED</h4>

<p>默认的事务传播特性，通常情况下我们用这个事务传播特性就可以了。如果当前事务上下文中没有事务，那么就会新创建一个事务。如果当前的事务上下文中已经有一个事务了，那么新开启的事务会开启一个新的逻辑事务范围，但是会和原有的事务共用一个物理事务，我们暂且不关心逻辑事务和物理事务的区别，先看看这样会导致怎样的代码行为：</p>

<p>```java
@Override
public void txRollbackInnerTxRollbackPropagationRequires() {</p>

<pre><code>transactionTemplate.execute(new TransactionCallbackWithoutResult() {
    @Override
    protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) {
        jdbcTemplate.update("insert into user (name, password) values (?, ?)", "Huang",
            "1111112");
        transactionTemplate.execute(new TransactionCallbackWithoutResult() {
            @Override
            protected void doInTransactionWithoutResult(TransactionStatus status) {
                jdbcTemplate.update("insert into user (name, password) values (?, ?)",
                    "Huang", "1111112");
                // 内部事务设置了 setRollbackOnly，
                status.setRollbackOnly();
            }
        });
    }
});
</code></pre>

<p>}
```</p>

<p>这段代码在一个嵌套的事务内部（内外层的事务都是 PROPAGATION_REQUIRED 的）设置了回滚，那么对于外部的事务来说，它会收到一个 <code>UnexpectedRollbackException</code>，因为内部的事务和外部的事务是共用一个物理事务的，所以显然内部的事务必然会导致外部事务的回滚，但是因为这个回滚并不是外部事务自己设置的，所以外层事务回滚的时候会需要抛出一个 <code>UnexpectedRollbackException</code>，让事务的调用方知道这个回滚并不是外部事务自己想要回滚，是始料未及的。</p>

<p>但是，如果内层的事务不是通过设置 <code>setRollbackOnly()</code> 来回滚，而是抛出了 <code>RuntimeException</code> 来回滚，那么外层的事务接收到了内层抛出的 <code>RuntimeException</code> 也会跟着回滚，这个是可以预料到的行为，所以不会有 <code>UnexpectedRollbackException</code> 。</p>

<h4>PROPAGATION_SUPPORTS</h4>

<p>PROPAGATION_SUPPORTS 的特性是如果事务上下文中已经存在一个事务，那么新的事务（传播特性为 PROPAGATION_SUPPORTS）就会和原来的事务共用一个物理事务，其行为和 PROPAGATION_REQUIRED 一样。但是，如果当前事务上下文中没有事务，那么 PROPAGATION_SUPPORTS 就按无事务的方式执行代码：</p>

<p>```java
@Override
public void txRollbackInnerTxRollbackPropagationSupports() {</p>

<pre><code>supportsTransactionTemplate.execute(new TransactionCallbackWithoutResult() {
    @Override
    protected void doInTransactionWithoutResult(TransactionStatus status) {
        jdbcTemplate.update("insert into user (name, password) values (?, ?)", "Huang",
            "1111112");
        throw new CustomRuntimeException();
    }
});
</code></pre>

<p>}
```</p>

<p>看上面这段代码，虽然我们在事务（PROPAGATION_SUPPORTS 的）中抛出了一个 <code>RuntimeException</code>，但是因为其事务上下文中没有事务存在，所以这段代码实际上是以无事务的方式执行的，因此代码中的 <code>jdbcTemplate.update()</code> 操作也不会被回滚。</p>

<h4>PROPAGATION_MANDATORY</h4>

<p>PROPAGATION_MANDATORY 要求事务上下文中必须存在事务，如果事务上下文中存在事务，那么其行为和 <code>PROPAGATION_REQUIRED</code> 一样。如果当前事务上下文中没有事务，那么就会抛出 <code>IllegalTransactionStateException</code>，比如下面这段代码就会这样：</p>

<p>```java
@Override
public void txRollbackInnerTxRollbackPropagationMandatory() {</p>

<pre><code>mandatoryTransactionTemplate.execute(new TransactionCallbackWithoutResult() {
    @Override
    protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) {
        jdbcTemplate.update("insert into user (name, password) values (?, ?)", "Huang",
            "1111112");
    }
});
</code></pre>

<p>}
```</p>

<h4>PROPAGATION_REQUIRES_NEW</h4>

<p>PROPAGATION_REQUIRES_NEW 无论当前事务上下文中有没有事务，都会开启一个新的事务，并且和原来的事务完全是隔离的，外层事务的回滚不会影响到内层的事务，内层事务的回滚也不会影响到外层的事务（<strong>这个说法得稍微打点折扣：因为如果内层抛出 <code>RuntimeException</code> 的话，那么外层还是会收到这个异常并且触发回滚</strong>），我们分析下几段代码：</p>

<p>```java
@Override
public void txRollbackInnerTxRollbackPropagationRequiresNew() {</p>

<pre><code>transactionTemplate.execute(new TransactionCallbackWithoutResult() {
    @Override
    protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) {

        requiresNewTransactionTemplate.execute(new TransactionCallbackWithoutResult() {
            @Override
            protected void doInTransactionWithoutResult(TransactionStatus status) {
                jdbcTemplate.update("insert into user (name, password) values (?, ?)",
                    "Huang", "1111112");
            }
        });

        // 外部事务发生回滚，内部事务应该不受影响还是能够提交
        throw new RuntimeException();
    }
});
</code></pre>

<p>}
```</p>

<p>这段代码外层的事务回滚了，但是不会影响到内层的事务的提交，内层事务不受外层的事务的影响。再看：</p>

<p>```java
@Override
public void txRollbackInnerTxRollbackPropagationRequiresNew2() {</p>

<pre><code>transactionTemplate.execute(new TransactionCallbackWithoutResult() {
    @Override
    protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) {
        jdbcTemplate.update("insert into user (name, password) values (?, ?)", "Huang",
            "1111112");
        // Nested transaction committed.
        requiresNewTransactionTemplate.execute(new TransactionCallbackWithoutResult() {
            @Override
            protected void doInTransactionWithoutResult(TransactionStatus status) {
                jdbcTemplate.update("insert into user (name, password) values (?, ?)",
                    "Huang", "1111112");
                // 内部事务发生回滚，但是外部事务不应该发生回滚
                status.setRollbackOnly();
            }
        });
    }
});
</code></pre>

<p>}
```</p>

<p>这段代码在内层事务上设置了 <code>setRollbackOnly</code>，内层事务肯定会回滚，但是由于内层事务和外层事务是隔离的，所以外层事务不会被回滚。再看：</p>

<p>```java
@Override
public void txRollbackInnerTxRollbackPropagationRequiresNew3() {</p>

<pre><code>transactionTemplate.execute(new TransactionCallbackWithoutResult() {
    @Override
    protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) {
        jdbcTemplate.update("insert into user (name, password) values (?, ?)", "Huang",
            "1111112");

        requiresNewTransactionTemplate.execute(new TransactionCallbackWithoutResult() {
            @Override
            protected void doInTransactionWithoutResult(TransactionStatus status) {
                jdbcTemplate.update("insert into user (name, password) values (?, ?)",
                    "Huang", "1111112");
                // 内部事务抛出 RuntimeException，外部事务接收到异常，依旧会发生回滚
                throw new RuntimeException();
            }
        });
    }
});
</code></pre>

<p>}
```</p>

<p>这段代码在内层事务抛出了一个 <code>RuntimeException</code>，虽然内层事务和外层事务在事务上是隔离，但是 <code>RuntimeException</code> 显然还会抛到外层去，所以外层事务也会发生回滚。</p>

<h4>PROPAGATION_NOT_SUPPORTED</h4>

<p>PROPAGATION_NOT_SUPPORTED 不管当前事务上下文中有没有事务，代码都会在按照无事务的方式执行，看下面这段代码：</p>

<p>```java
@Override
public void txRollbackInnerTxRollbackPropagationNotSupport() {</p>

<pre><code>transactionTemplate.execute(new TransactionCallbackWithoutResult() {
    @Override
    protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) {
        jdbcTemplate.update("insert into user (name, password) values (?, ?)", "Huang",
            "1111112");
        notSupportedTransactionTemplate.execute(new TransactionCallbackWithoutResult() {
            @Override
            protected void doInTransactionWithoutResult(TransactionStatus status) {
                jdbcTemplate.update("insert into user (name, password) values (?, ?)",
                    "Huang", "1111112");
            }
        });
        // 外部事务回滚，不会把内部的也连着回滚 
        transactionStatus.setRollbackOnly();
    }
});
</code></pre>

<p>}
```</p>

<p>上面这段代码中虽然外部事务发生了回滚，但是由于内部的事务是 PROPAGATION_NOT_SUPPORTED，根本不在外层的事务范围内，所以内层事务不会发生回滚。</p>

<h4>PROPAGATION_NEVER</h4>

<p>PROPAGATION_NEVER 如果当前事务上下文中存在事务，就会抛出 <code>IllegalTransactionStateException</code> 异常，自己也会按照非事务的方式执行</p>

<p>```java
@Override
public void txRollbackInnerTxRollbackPropagationNever2() {</p>

<pre><code>transactionTemplate.execute(new TransactionCallbackWithoutResult() {
    @Override
    protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) {
        jdbcTemplate.update("insert into user (name, password) values (?, ?)", "Huang",
            "1111112");
        neverTransactionTemplate.execute(new TransactionCallbackWithoutResult() {
            @Override
            protected void doInTransactionWithoutResult(TransactionStatus status) {
                jdbcTemplate.update("insert into user (name, password) values (?, ?)",
                    "Huang", "1111112");
            }
        });
    }
});
</code></pre>

<p>}
```</p>

<p>比如上面这段代码，在一个 PROPAGATION_REQUIRES 里面嵌入了一个 PROPAGATION_NEVER，内层就会抛出一个 <code>IllegalTransactionStateException</code>，导致外层事务被回滚。</p>

<h4>PROPAGATION_NESTED</h4>

<p>PROPAGATION_NESTED 只能应用于像 DataSource 这样的事务，可以通过在一个事务内部开启一个 PROPAGATION_NESTED 而达到一个事务内部有多个保存点的效果，一个内嵌的事务发生回滚，只会回滚到它自己的保存点，外层事务还会继续，比如下面这段代码：</p>

<p>```java
@Override
public void txRollbackInnerTxRollbackPropagationNested() {</p>

<pre><code>nestedTransactionTemplate.execute(new TransactionCallbackWithoutResult() {
    @Override
    protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) {
        jdbcTemplate.update("insert into user (name, password) values (?, ?)", "Huang",
            "1111112");

        nestedTransactionTemplate.execute(new TransactionCallbackWithoutResult() {
            @Override
            protected void doInTransactionWithoutResult(TransactionStatus status) {
                jdbcTemplate.update("insert into user (name, password) values (?, ?)",
                    "Huang", "1111112");
                // 内部事务设置了 rollbackOnly，外部事务应该不受影响，可以继续提交
                status.setRollbackOnly();
            }
        });
    }
});
</code></pre>

<p>}
```</p>

<p>内层的事务发生了回滚，只会回滚其内部的操作，不会影响到外层的事务。</p>

<h3>总结</h3>

<p>Spring 的事务传播特性种类繁多，大多数都来自于 EJB 的事务，大家可以自己写一些小的程序来测试 Spring 各个事务特性的行为，加深印象，我自己也写了一个工程，通过单元测试去测试各个事务传播特性的行为，大家有兴趣的话，可以下过来跑一下：<a href="https://github.com/khotyn/spring-tx-test">https://github.com/khotyn/spring-tx-test</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从 JVM 中 dump class 的几种方法]]></title>
    <link href="http://khotyn.github.com/blog/2013/08/03/dumping-class-from-jvm/"/>
    <updated>2013-08-03T14:04:00+08:00</updated>
    <id>http://khotyn.github.com/blog/2013/08/03/dumping-class-from-jvm</id>
    <content type="html"><![CDATA[<p>前几天在 HotCode 的用户群里面，有同学问起“如何将 JVM 中的 class dump 出来”，当时我下意识的回答就是“可以在 JVM 启动的时候挂一个 agent 上去，然后通过 Instrumentation API 在 class 加载的时候做拦截，把类 dump 出来。”，今天无聊在翻 <a href="http://weibo.com/rednaxelafx">R 大</a>的<a href="http://rednaxelafx.iteye.com/blog/727938">博客</a>的时候，发现还可以通过 sa-jdi.jar 里面的一个类做 dump，这里就集中介绍一下这几个方法，然后介绍我在 sa-jdi.jar 基础上改的一个小工具。</p>

<h3>采用 classLoader.getResourceAsStream()</h3>

<p>将一个类从 JVM 中 dump 出来，最简单的方法当然就是直接从 jar 包中把对应的 class 文件找到，然后 dump 出来了，我们可以用 <code>classLoader</code> 的 <code>getResourceAsStream</code> 来做：</p>

<p><code>java
ClassLoader loader = Thread.currentThread().getContextClassLoader();
InputStream in = loader.getResourceAsStream("com/khotyn/Test.class");
</code></p>

<p>拿到 InputStream 后，你就可以随便玩了。</p>

<p>这个方法简单是简单，但是缺点也很明显，在有些 Java 程序中，类不一定是从 Class 文件中过来，有些是在运行时生成的，有些则在载入到 JVM 之前被增强过，所以这个方法有些类是 dump 不出来的，有些类则 dump 出来不是你想要的。</p>

<h3>采用 javaagent</h3>

<p>另外一个方法是通过在 JVM 启动的时候挂在一个 javaagent，然后用 Instrucmentation API 在类被加载到虚拟机之前做拦截，参考代码如下：</p>

<p>```java
package com.khotyn.test;</p>

<p>import java.io.File;
import java.io.IOException;
import java.lang.instrument.ClassFileTransformer;
import java.lang.instrument.IllegalClassFormatException;
import java.lang.instrument.Instrumentation;
import java.security.ProtectionDomain;</p>

<p>import org.apache.commons.io.FileUtils;</p>

<p>/<em>*
 * A demo to demonstrate how to use JVM ti to dump class file from JVM.
 *
 * @author khotyn.huangt 13-8-3 PM2:21
 </em>/
public class AgentMain {</p>

<pre><code>public static void premain(String agentArgs, Instrumentation inst) {
    inst.addTransformer(new ClassFileTransformer() {

        @Override
        public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,
                                ProtectionDomain protectionDomain, byte[] classfileBuffer)
                                                                                          throws IllegalClassFormatException {
            try {
                FileUtils.writeByteArrayToFile(new File("/tmp/" + className.replace('.', '/') + ".class"),
                                               classfileBuffer);
            } catch (IOException e) {
                // Quite
            }
            return null;
        }
    });
}
</code></pre>

<p>}
```</p>

<p>将上面的代码打成一个 jar 包（<em>注意把依赖的 apache commons.io 也打入，也可以直接下载我的 demo 工程：<a href="http://pan.baidu.com/share/link?shareid=778648109&amp;uk=607430891">agentDumpClass.zip</a></em>），然后在 jar 包的 <code>META-INF/MANIFEST.MF</code> 中填上如下的内容：</p>

<p><code>
Manifest-Version: 1.0
Boot-Class-Path: agentDump.jar
Built-By: apple
Build-Jdk: 1.7.0_17
Class-Path: lib/commons-io-2.4.jar
Premain-Class: com.khotyn.test.AgentMain
Created-By: Apache Maven
Can-Redefine-Classes: true
Archiver-Version: Plexus Archiver
</code></p>

<p>然后你就可以执行类似于下面的命令来进行 dump 了：</p>

<p><code>
java -javaagent:/Users/apple/workspace/agentDumpClass/target/agentDump.jar Test
</code></p>

<p>由于 premain 方法是在 java 程序的 main 方法执行之前执行的，所以这个方法几乎可以拦截到所有的类，另外，由于注册的 ClassFileTransformer 是 ClassLoader 加载 class 之后，JVM 定义 class 之前被执行的，所以无论是在运行时生成的类，还是经过增强后的类，这个方法都能够 dump 出来，比第一种方法要强很多。然而这个方法还是有一些缺点：</p>

<ul>
<li>需要在 JVM 启动时增加特别的参数。</li>
<li>只能随 class 被加载进行 dump，不能随时进行 dump</li>
</ul>


<h3>采用 sa-jdi.jar 的 ClassDump 工具</h3>

<p>这个方式是 R 大在博客中介绍的方法，可以说是最强大的方法，不像前面的两个方法，这个方法可以在 JVM 进程外执行，且像 javaagent 的那个方法一样，都可以将运行时和被增强过的类 dump 出来，非常方便，至于具体的用法大家就直接看 <a href="http://rednaxelafx.iteye.com/blog/727938">R 大的文章</a>吧。</p>

<h3>改进 ClassDump</h3>

<p>ClassDump 工具虽然强大，但是命令略显繁琐，特别是当你只需要 dump 特定的类的时候，还需要专门写一个 ClassFilter 的实现类，这么好的工具，应该直接做成命令行工具才好，于是我修改了 ClassDump 的代码，让它可以支持正则表达式的方式来对需要 dump 的类进行过滤，改进后的 ClassDump 放在了我的 github 仓库上：<a href="https://github.com/khotyn/tools">https://github.com/khotyn/tools</a></p>

<p>大家可以直接用下面的方式来使用这个改进版：</p>

<p><code>
sudo classDump 17118 'com.khotyn.*' dump
</code></p>

<p>classDump 这个命令的第一个参数是目标 JVM 的 PID，第二个参数是一个正则表达式，表示你所要 Dump 出来的类，第三个参数可选，是 dump 的目录。</p>

<p>但是这个工具有一个缺点，就是目前只能在 Mac 下用（因为我用 Mac，呵呵，我把修改后的类直接打入到了 Mac 的 jdk 的 sa-jdi.jar 下面），不过要做其他的平台的也很简单啦，只要按照以下步骤来打包出自己的 sa-jdi.jar 就可以：</p>

<ul>
<li>下载我修改过的两个类：<a href="http://pan.baidu.com/share/link?shareid=780474506&amp;uk=607430891">ClassDump.class</a>，<a href="http://pan.baidu.com/share/link?shareid=782905423&amp;uk=607430891">RegexClassFilter.class</a></li>
<li>从 jdk 目录下拷贝一份 sa-jdi.jar 出来</li>
<li>用下面的命令将修改过的两个类打到 sa-jdi.jar 中去：<code>jar uf sa-jdi.jar sun/jvm/hotspot/tools/jcore/ClassDump.class sun/jvm/hotspot/tools/jcore/RegexClassFilter.class</code></li>
<li>然后配合仓库中的 classDump 脚本就可以用了。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[「Sed & Awk」阅读笔记之 Sed 高级命令]]></title>
    <link href="http://khotyn.github.com/blog/2013/07/30/sed-part-two/"/>
    <updated>2013-07-30T21:41:00+08:00</updated>
    <id>http://khotyn.github.com/blog/2013/07/30/sed-part-two</id>
    <content type="html"><![CDATA[<p>上一篇文章中，我介绍了一下 <a href="../../../../2013/07/28/sed-and-awk-part-one/">sed 的基础</a>，包括执行方式、地址选择器以及基本命令，在这一篇文章中，我们继续来了解一下 sed 的高级命令，之所以称它们为高级命令，是因为这些命令会改变 sed 的执行流，废话不说，我们来看看这些命令吧：</p>

<h3>高级命令</h3>

<h4>N (Next)</h4>

<p>这里要介绍的第一个命令是 <code>N</code>，它和我们前面介绍过的 <code>n</code> 命令很像，也是要读取下一行的内容，不同的是，<code>N</code> 读取下一行的内容并且将这些内容附加到 pattern space 当前的内容后面。这样，当你需要连着处理多行内容的时候，<code>N</code> 命令就会特别有用，比如，我们有下面一段文本：</p>

<p><code>
one two three four
one two three
four three two
three four
</code></p>

<p>如果我们要把 <code>two three four</code> 替换成 <code>2 3 4</code>，注意例子中的 <code>two three four</code> 可能在不同的行中，那么我们就可以用 <code>N</code> 命令来处理：</p>

<p><code>
N
s/\n/ /
s/two three four/2 3 4/
</code></p>

<p>输出的内容为：</p>

<p><code>
one 2 3 4 one two three
four three 2 3 4
</code></p>

<p>这个结果不是我们想要的，不过的确是符合了上面的 sed 脚本的执行结果：</p>

<ol>
<li>首先，sed 脚本读取了文本的第一行，这个时候 pattern space 中的内容为 <code>one two three four</code></li>
<li>然后 sed 脚本执行 N 命令，将下一行读取并附加到当前的 pattern space 内容的后面，这个时候，pattern space 中的内容就变为 <code>one two three four\none two three</code></li>
<li>下一个命令，将换行符 <code>\n</code> 替换成一个空格，pattern space 中的内容为 <code>one two three four one two three</code></li>
<li>然后下一个命令，将 pattern space 中的 <code>two three four</code> 替换成 <code>2 3 4</code>，这个时候 pattern space 中的内容为 <code>one 2 3 4 one two three</code></li>
<li>到达脚本的结尾，输出 pattern space 中的内容，也就是我们输出内容的第一行。</li>
<li>然后 sed 脚本读取文本的下一行，注意因为之前第二行已经被 <code>N</code> 命令读取了，所以 sed 脚本开始读取第三行，依旧按照前面的命令执行，最后就输出了输出内容中的第二行。</li>
</ol>


<p>虽然这个结果不是我们想要的，不过算是了解了 N 的作用了。</p>

<h4>D (Delete)</h4>

<p>同样，前面我们介绍过 <code>d</code> 命令，它用来删除 pattern space 中的内容，并且读取下一行到 pattern space 中，sed 脚本也随之从头开始执行。<code>D</code> 命令和 <code>d</code> 命令稍微有点不同，<code>D</code> 命令会删除 pattern space 中的第一行的内容，它不会从文本中读取新的行进来，当然 sed 脚本还是会从头开始执行，如果我们有这么一个文本：</p>

<p>```
blank
blank</p>

<p>blank</p>

<p>blank</p>

<p>blank</p>

<p>blank
```</p>

<p>这个文本中的有些段落之间有多个空行，我们希望把多余的空行去掉，也就是如果段落之间有多个空行，就删掉只剩下一个，我们的 sed 脚本可以这么写：</p>

<p>```
/<sup>$/{</sup></p>

<pre><code>N
/^\n$/D
</code></pre>

<p>}</p>

<p>```</p>

<p>这个脚本先匹配出空行，然后读取空行的下一行，如果两行都是空行的话，就把 pattern space 中的第一个空行删除掉，然后继续读取下一行到 pattern space 中，结果就是把多余的空行都删除掉，只剩下一个空行了。</p>

<h4>P (Print)</h4>

<p><code>P</code> 命令和 <code>p</code> 命令也稍微不同，<code>P</code> 命令不像 <code>p</code> 命令那样会把 pattern space 中的所有内容打印出来，它只会将 pattern space 的第一行打印出来，这里就不做过多的介绍了。</p>

<h4>h (hold), H (Hold), g (get), G (Get), x (exchange)</h4>

<p>这里面有五个命令，之所以一起介绍是因为，这五个命令都是操作 hold space 的，之前我们已经知道了 pattern space 了，hold space 可以认为就是一个内容的临时存放点，你可以将 pattern space 中的内容放到 hold space 中，等到需要使用的时候再将 hold space 中的内容拿回到 pattern space 中，我们来看一下这五个命令的作用吧：</p>

<ul>
<li>h：将 pattern space 中的内容拷贝到 hold space 中，hold space 中原来的内容会被覆盖。</li>
<li>H：将 pattern space 中的内容添加到 hold space 当前内容的后面。</li>
<li>g：将 hold space 中的内容拷贝到 pattern space 中，pattern space 中原来的内容将会被覆盖。</li>
<li>G：将 hold space 中的内容添加到 pattern space 中目前的内容后面。</li>
<li>x：交换 pattern space 和 hold space 中的内容。</li>
</ul>


<p>下面我们来看一个简单的例子：</p>

<p><code>
1
2
11
22
111
222
</code></p>

<p>现在我们要将上面的 1 和 2 的位置调换，就是先出现 2 再出现 1，我们的脚本可以这么写：</p>

<p>```
/1/{</p>

<pre><code>h
d
</code></pre>

<p>}
/2/{</p>

<pre><code>G
</code></pre>

<p>}
```</p>

<p>这段脚本先匹配 1 所在的行，然后放到 hold space 中，将 pattern space 中的内容清除掉，然后匹配到 2 所在的行，将 hold space 中的内容添加到 pattern space 后面，这样，pattern space 中就是先有 2，再有 1 了。</p>

<p>最后，我们得到的结果就是：</p>

<p><code>
2
1
22
11
222
111
</code></p>

<h4>b</h4>

<p><code>b</code> 命令是一个跳转命令，它是无条件的，它的语法是这样的：</p>

<p><code>
[address]b [label]
</code></p>

<p>[label] 是要跳转到的标签，你可以在 sed 脚本中用 <code>:</code> 开头来表示一个标签，比如下面的：</p>

<p><code>
:start
s/start/end/g
b start
</code></p>

<p>如果 <code>b</code> 后面不带参数，那么就表示直接跳到脚本的末尾了。</p>

<h4>t</h4>

<p>除了 <code>b</code> 这样一个跳转命令以外，sed 还有一个 <code>t</code> 的条件跳转命令，如果在当前行有一个替换被成功执行了，那么 <code>t</code> 就会跳转到特定的标签上，它的语法 <code>b</code> 是类似的。</p>

<p><code>
[address]t [label]
</code></p>

<p>看下面这段代码：</p>

<p><code>
:begin
s/start/end/
t begin
</code></p>

<p>这条 <code>t</code> 命令只有在当前行的 start 成功被替换成 end 的时候才会跳转到 :begin 标签那里。</p>

<h3>总结</h3>

<p>sed 的高级命令相对于基本命令来说不怎么常用，但是在处理特定的问题的时候，这些命令还是很有用的。不过，不管怎么说，sed 都不是一门完备的语言，所以其适用的问题域也是比较有限的，sed 最大的优势在于逐行处理文本上，用适当的工具处理适当的问题，才能发挥出工具最大的威力。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[「Sed & awk」阅读笔记之 sed 基础]]></title>
    <link href="http://khotyn.github.com/blog/2013/07/28/sed-and-awk-part-one/"/>
    <updated>2013-07-28T16:39:00+08:00</updated>
    <id>http://khotyn.github.com/blog/2013/07/28/sed-and-awk-part-one</id>
    <content type="html"><![CDATA[<p>之前写的一篇文章有提到采用 sed 来<a href="../../../../blog/2013/07/24/match-line-not-contain-a-string/">匹配不包含连续字符串的行</a>，平时在做日志分析的时候也经常要用到 sed，但是仅仅用了 sed 的字符串替换的功能，没有系统地去学习过 sed 用法，这次找到一本叫<a href="http://book.douban.com/subject/1741933/">「sed &amp; awk」</a>的书，便花时间对 sed 做了系统的学习。</p>

<h3>sed 的执行方式</h3>

<p>要了解 sed，必须了解 sed 的执行方式，sed 是一个行处理器，脱胎于 <a href="http://www.gnu.org/software/ed/manual/ed_manual.html">ed</a>（ed 是一个行编辑器，awk 和 grep 也是基于 ed 的），简单地说，sed 的执行方式是这样的：<strong>sed 会从输入的文本中读取一行，放到 pattern space 中，然后用 sed 脚本去处理，处理完后继续读取下一行，继续处理。</strong></p>

<p>假设我们有下面一段文本需要处理：</p>

<p><code>
John Daggett, 341 King Road, Plymouth MA
Alice Ford, 22 East Broadway, Richmond VA
Orville Thomas, 11345 Oak Bridge Road, Tulsa OK
Terry Kalkas, 402 Lans Road, Beaver Falls PA
Eric Adams, 20 Post Road, Sudbury MA
Hubert Sims, 328A Brook Road, Roanoke VA
Amy Wilde, 334 Bayshore Pkwy, Mountain View CA
Sal Carpenter, 73 6th Street, Boston MA
</code></p>

<p>我们要把文本中的 CA 替换成 California，OK 替换成 Oklahoma，于是我们写了下面一段 sed 脚本：</p>

<p><code>
s/CA/California/
s/OK/Oklahoma/
</code></p>

<p>那么 sed 的执行方式是这样的：</p>

<ol>
<li>先读取第一行 <code>John Daggett, 341 King Road, Plymouth MA</code> 到 pattern space</li>
<li>然后执行脚本的第一行命令，将其中的 CA 替换成 California。</li>
<li>然后执行脚本的第二行命令，将其中的 OK 替换成 Oklahoma。</li>
<li>文本的第一行处理完毕，继续读取文本的下一行。</li>
<li>继续第 2 步和第 3 步。</li>
</ol>


<p>当然，这只是大部分情况下 sed 的执行方式，sed 的基本命令都是按照这种方式来执行的，一些高级命令可以改变 sed 的执行流。不过在了解这些 sed 命令之前，我们先了解下 sed 的地址选择器，它是很多命令的组成部分。</p>

<h3>sed 的地址选择器</h3>

<p>默认的情况，sed 脚本会对文本的每一行做处理，但是有时候我们只希望我们的命令作用于特定的几行，这个时候，我们就可以用 sed 的地址选择器，sed 的地址选择器可以是一个正则表达式（sed 的正则表达式总是放在两个 <code>/</code> 中间），行号，或者地址符号（<em>这个是什么东西？我也不清楚</em>），具体的使用方式如下：</p>

<ul>
<li>如果没有指定地址选择器，那么命令默认会应用在每一行上。</li>
<li>如果只有一个地址选择器，那么命令会作用在每一个符合这个地址选择器的行上。</li>
<li>如果是两个用 <code>,</code> 分割的地址，那么命令会先作用到第一个符合第一个地址选择器的行上，然后继续作用于后续的行，直到（包括）第一个符合第二个地址选择器的行为止。</li>
<li>地址选择器后面可以跟上一个 <code>!</code>，表示反向选择。</li>
</ul>


<p>另外在一个地址选择器中，你可以用一对 <code>{}</code> 将多个命令包含在其中，下面我们来看一个例子：</p>

<p>```
/<sup>.TS/,/<sup>.TE/{</sup></sup></p>

<pre><code> /^$/d
 s/^\.ps 10/.ps 8/
 s/^\.vs 12/.vs 10/
</code></pre>

<p>}</p>

<p>```</p>

<p>这个 sed 脚本的第一行就是一个地址选择器，由 <code>,</code> 分开的两个地址选择器组成，都是正则表达式形式的，表示后面 <code>{}</code> 中的命令会从第一个以 <code>.TS</code> 开头的行一直作用到第一个以 <code>.TE</code> 开头的行为止。</p>

<h3>sed 的基本命令</h3>

<p>了解完 sed 的地址选择器后，我们就可以继续了解 sed 的基本命令了。</p>

<h4>替换（substitution）</h4>

<p>sed 的文本替换命令是我最常用的命令，它的语法是这样的：</p>

<p><code>
[address]s/pattern/replacement/flags
</code></p>

<p>它由这几个部分组成：</p>

<ul>
<li>最前面是一个地址选择器，是可选的。</li>
<li>然后后面是一个命令 <code>s</code>，表示是替换命令。</li>
<li>后面紧跟一个正则表达式，表示要被替换的文本。</li>
<li>再后面是希望替换成的文本。</li>
<li>最后是标记位。</li>
</ul>


<p>其中标记位可以是：</p>

<ul>
<li>n：一个从 1 到 512 的数字，表示只替换第 n 个符合 pattern 子串。</li>
<li>g：默认情况下，替换命令只会替换一行中第一个符合 pattern 的子串，加上 <code>g</code> 以后会将行中所有符合 pattern 的子串都进行替换。</li>
<li>p：将 pattern space 中的内容打印出来。</li>
<li>w <em>file</em> ：将 pattern space 中的内容写到文件中。</li>
</ul>


<p>举一个例子，假设我们要将第一个例子中的最后一行的 MA 换成 Massachusetts，就可以这样写：</p>

<p><code>
$s/MA/Massachusetts/
</code></p>

<p>其中的 <code>$</code> 是一个地址选择器，表示最后一行。</p>

<p>替换命令的替换文本基本上就是一个字符串，但是还是有一些特殊字符：<code>\</code>，<code>&amp;</code> 和 <code>\n</code>，其中：</p>

<ul>
<li><code>\</code>：转义，转义特殊字符。</li>
<li><code>&amp;</code>：代表要被替换的文本，也就是符合 pattern 的子串。</li>
<li><code>\n</code>：当前面的正则表达式中有捕获部分的时候（即，正则表达式的 <code>()</code> 语法），可以在替换文本中用这种反向引用的方式进行引用。</li>
</ul>


<p>这些特殊字符在当你需要将匹配的文本中的某些部分放到替换文本中的时候会特别有用。</p>

<h4>删除（delete）</h4>

<p>删除命令很简单，它的语法是：</p>

<p><code>
[address]d
</code></p>

<p>前面可以带一个地址选择器，后面是一个 d，表示删除命令，举一个简单的例子，假设我们要筛选出不包含 <code>abc</code> 的行，可以这样写：</p>

<p><code>
/abc/d
</code></p>

<p>把包含 abc 的行全部都删除掉，这样就筛选出了不包含 <code>abc</code> 的行。</p>

<h4>追加，插入和变化（append，insert，change）</h4>

<p>这三个命令的作用分别是：insert 将提供的文本插入到 pattern space 的当前行前面，append 将提供的文本追加到 pattern space 的当前行后面，change 命令替换 pattern space 中的内容，之所以将这三个命令放到一起说，是因为这三个命令需要将提供的文本放在命令的第二行，它们的语法分别是这样的：</p>

<p>append</p>

<pre><code>[line-address]a\
text
</code></pre>

<p>insert</p>

<pre><code>[line-address]i\
text
</code></pre>

<p>changae</p>

<pre><code>[address]c\
text
</code></pre>

<p>来一个例子，我们有下面一段文本：</p>

<p><code>
I want to see @f1(what will happen) if we put the
font change commands @f1(on a set of lines).
If I understand things (correctly), the @f1(third) line causes problems. (No?).
Is this really the case, or is it (maybe) just something else?
Let's test having two on a line @f1(here) and @f1(there) as
well as one that begins on one line and ends @f1(somewhere
on another line).
What if @f1(it is here) on the line?
Another @f1(one).
</code></p>

<p>假设为了阅读的美观，我们希望段落之间能够空出一行来，段落结束的标记我们暂且简单地假设以 <code>.</code> 结尾，我们要做的就是在每一个以 <code>.</code> 结尾的行后面再插入一行，除了最后一行之外，那么我们的 sed 脚本就可以这么写：</p>

<p>```
$!{</p>

<pre><code>/\.$/a\
\
</code></pre>

<p>}
```</p>

<p>来说明一下这段脚本，第一行是一个地址选择器，表示选择除最后一行以外的行，因为我们不希望在最后一个段落后面也加上一个空行，然后里面的命令是对所有的以 <code>.</code> 结尾的行运用 a 命令去追加一个空行。</p>

<h4>列出（list）</h4>

<p>列出命令和打印命令其实很像，不同的是列出命令会将不可见字符给列出来，比如 windows 下的换行符，假设我们有下面一段文本（<code>^M</code> 可以用 Ctrl+V，然后 Ctrl+M 来输入）：</p>

<p><code>
^M^M
^M
^M^M^M
</code></p>

<p>上面一段文本用 <code>sed -n 'l'</code> 输出的内容是：</p>

<p><code>
\r\r$
\r$
\r\r\r$
</code></p>

<p>而用 <code>sed -n 'p'</code> 输出的内容是三个空空的行。</p>

<p>列出命令将不可见字符打印出来了，而打印命令则没有。</p>

<h4>转换（transform）</h4>

<p>转换命令和替换命令听起来是一样，但是它们还是不同的，转换命令就像是多个 <code>tr</code> 命令用管道连在一起作用一样，它的语法是：</p>

<p><code>
[address]y/abc/xyz/
</code></p>

<p>转换命令的一个使用的场景就是大小写的转换：</p>

<p><code>
y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/
</code></p>

<p>上面这个命令会将文本中所有的小写字母转换成大写字母。</p>

<h4>打印（print）</h4>

<p>打印命令其实就是一个简单的 <code>p</code>，将 pattern space 中的内容打印出来，比如：</p>

<p><code>
$!p
</code></p>

<p>表示将除最后一行以外的内容全部打印出来。需要注意的是，默认情况下 sed 会将 pattern space 中的内容都打印出来，要关闭这个功能，可以加上一个 <code>-n</code> 参数，就像我在介绍列出命令的时候做的那样。</p>

<h4>打印行号</h4>

<p>打印行号也就是一个简单的 <code>=</code> 号，大家可以去试一下，这里不再多讲了。</p>

<h4>下一个（next）</h4>

<p>next 命令是一个 <code>n</code>，它的作用是将 pattern space 中的内容立即输出，然后将下一行读入到 pattern space 中，然后继续执行接下来的命令，比如：</p>

<pre><code>/H1/{
    n
/^$/d
}
</code></pre>

<p>就是先匹配到含有 H1 的行，然后将这一行打印出来，接着读取下一行到 pattern space，如果是空的话，就删除掉。</p>

<h4>读取和写入文件（read，write）</h4>

<p>sed 的读取文件的功能可以将文件中的内容追加到 pattern space 后面，前面那个在段落后面添加空行的例子我们可以这么做：首先创建一个只包含一个空行的文件叫做 temp，接着我们就可以用下面的命令来达到我们的目的了：</p>

<p>```
$!{</p>

<pre><code>/\.$/r temp
</code></pre>

<p>}
```</p>

<p>sed 的写入文件的功能和读取文件的功能类似，语法是：</p>

<p><code>
[address]w file
</code></p>

<p>表示将 pattern space 中的内容写入到文件。</p>

<h4>退出（quit）</h4>

<p>sed 的退出命令是让 sed 停止读取新的行，也停止输出，基本上就是让 sed 退出了，它的命令的语法是：</p>

<p><code>
[line-address]q
</code></p>

<p>它只能作用在单行的地址选择器上。</p>

<h3>总结</h3>

<p>sed 的基本命令相对来说还是比较简单的，最主要的还是要用好地址选择器，在下一篇中，我会介绍一些 sed 的高级命令。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[再论如何匹配不包含连续字符串的行]]></title>
    <link href="http://khotyn.github.com/blog/2013/07/24/match-line-not-contain-a-string/"/>
    <updated>2013-07-24T22:35:00+08:00</updated>
    <id>http://khotyn.github.com/blog/2013/07/24/match-line-not-contain-a-string</id>
    <content type="html"><![CDATA[<p>在前一篇文章中，我讨论过如何使用<a href="http://blog.khotyn.com/blog/2013/07/24/zero-width-assert/">使用零宽断言来匹配不包含连续字符串的行</a>，这个方法采用了零宽断言这种不怎么常见的正则表达式用法，虽然行之有效，但是总归是个麻烦的方法，而且，零宽断言很多的正则表达式解释器都不支持，用 grep 的话，得加上 -P 参数，让 grep 采用 Perl 的方式解释正则表达式，更加遗憾的一点是 -P 参数似乎只有在 GNU 的版本中才有，在我的 Mac 上的 BSD 版本的 grep 中，并没有这个参数。</p>

<p>所幸的是今天无聊翻了翻 grep 的 man page，发现了几个更加方便的方法也更加通用的办法，在这里和大家分享一下：</p>

<h3>grep 的 invert match</h3>

<p>今天翻 grep 的 man page，发现了一个 <code>-v</code> 参数，它的说明是这样的：</p>

<blockquote><p>Selected lines are those not matching any of the specified patterns.</p></blockquote>

<p>正是我们想要，可以传入一个正则表达式，它帮你匹配不符合这个正则表达式的行，而且 <code>-v</code> 参数各个 grep 的版本都支持，无需担心换个系统就不能用的情况。</p>

<h3>采用 sed 来删除符合某个 pattern 的行</h3>

<p>其实不用 grep，用 sed 也可以做到这个需求，sed 本身就是一个强大的行处理工具，sed 可以用如下的方式把符合某个 pattern 的行给删除掉：</p>

<p><code>
sed '/pattern/D'
</code></p>

<p>怎么样？也是非常方便的吧，它可以做到和 grep 一样的功能，非常有效。</p>

<h3>采用 sed 来打印不符合某个 pattern 的行</h3>

<p>要用 sed 来解决这个问题，其实不止上面一个方法，还可以用以下的方法来做：</p>

<p><code>
sed -n '/pattern/!p'
</code></p>

<p>解释一下这段 sed 脚本的作用，首先是 <code>-n</code> 参数，大家知道 sed 的默认将处理和没有处理过的行都定向到输出流上，而 <code>-n</code> 参数是用来关闭这个功能，我们当然不希望 sed 将所有的行都打印出来。然后脚本的开始是一个行的选择器，前面是一个正则表达式（sed 的正则表达式都是放在两个斜杠之间的），后面的是一个<code>!</code>号，这样就表示选择反向选择，即选择不符合 pattern 的行，然后最后是一个 <code>p</code> 命令，把这样的行打印出来，这里的 pattern 当然可以是需求中的那个连续的字符串，这样，我们就达到了需求的目的了。</p>

<p>总结一下，推荐大家还是用 grep 的 invert match 或者 sed 来完成这个功能，零宽断言在解决这个问题上感觉有点杀鸡焉用牛刀（<strong>零宽断言还有很多适用的场景，不仅仅可以用来解决这个问题</strong>）。</p>
]]></content>
  </entry>
  
</feed>
