<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming | 小径分岔的花园]]></title>
  <link href="http://khotyn.github.com/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://khotyn.github.com/"/>
  <updated>2014-03-31T09:15:32+08:00</updated>
  <id>http://khotyn.github.com/</id>
  <author>
    <name><![CDATA[khotyn]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[一些关于单元测试的思考]]></title>
    <link href="http://khotyn.github.com/blog/2014/03/31/unittest/"/>
    <updated>2014-03-31T09:06:00+08:00</updated>
    <id>http://khotyn.github.com/blog/2014/03/31/unittest</id>
    <content type="html"><![CDATA[<p>最近在开发公司的集成测试框架，有一些关于单元测试的体会，写一个博客记录一下想法。</p>

<h4 id="section">为什么要写单元测试？</h4>

<p>这个问题，已经有无数的关于技术的书、文章去阐述了，不断地强调单元测试的重要性。比如单元测试可以让你在软件开发的早期阶段发现 Bug，而不必到集成测试的时候才发现等等。不过，对于我来说，在切实地戳到我的痛点之前，我一直都没有去重视这些关于单元测试的忠告（虽然在心中记着，但是实际上并不是很在意）。</p>

<p>在写公司的集成测试框架的时候，有那么好几次，在调整了现有的功能，或者修复了某个 Bug 之后，<strong>因为懒惰，也因为跑一次完整的单元测试所需要的耗时较长</strong>，我侥幸地认为这些修改应该没有问题，直接打包交付。结果是，墨菲定律出现了，果然，没有经过测试的修改引发了新的 Bug，我不得不重新修改代码，然后厚着脸皮让用户重新试一次。</p>

<p>人总是不靠谱的，我们懒惰，我们存在侥幸心理，坏事儿总是在我们最不希望发生的时候发生。写单元测试不能防止我们懒惰，防止我们存在侥幸心理。但是一次成本低廉的单元测试会让我们觉得：“反正运行一次但单元测试不会耗费很多时间，不如跑一次吧”，它在一定程度上降低我们犯错的几率。</p>

<p>单元测试对于重构的意义也非常重大。很多有意思的程序员都有洁癖，会想着去修改某一段「恶心」的代码。我有过这样几次经历，在把一段「恶心」的代码修改地赏心悦目后，最后上线后发现引入了一个 Bug，心里暗骂一句 WTF，然后一脸黑线地把 Bug 修改了，想想如果当时有单元测试，那么会给我多大的勇气，让我可以肆无忌惮地去重构代码，这是多么爽的一件事情。</p>

<h4 id="section-1">好的单元测试应该是怎样的？</h4>

<p>一个好的单元测试，我觉得最重要的一点就是运行成本得低，也就是说一个单元测试越快越好。运行一次单元测试的成本越低，你才会越愿意去运行单元测试。如果运行一次单元测试得 10 分钟 20 分钟，那么我想很多人的侥幸心理又会出来了。</p>

<h4 id="section-2">我是怎样写单元测试的？</h4>

<p>我一般是这样写单元测试的，先想清楚模块的边界，有哪几种可能的输入，这些输入对应的可能输出是什么，然后以最快的速度堆积代码把功能先实现出来，接着写单元测试，把测试用例全部跑过。接下来马上着手重构之前写的代码，不断重构，不断地跑单元测试，知道重构后的代码让自己满意为止。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关闭 Tomcat 的 TLD 扫描的功能]]></title>
    <link href="http://khotyn.github.com/blog/2014/01/21/turnoff-tomcat-tld-scan/"/>
    <updated>2014-01-21T19:12:00+08:00</updated>
    <id>http://khotyn.github.com/blog/2014/01/21/turnoff-tomcat-tld-scan</id>
    <content type="html"><![CDATA[<h3 id="section">背景</h3>

<p>Tomcat 作为 Servlet 规范的实现者，它在应用启动的时候会扫描 Jar 包里面的 .tld 文件，加载里面定义的标签库，但是，我们在开发的时候很多都不是采用 JSP 作为 Web 页面的模板的，很多都是使用  Velocity 之类的模板引擎，自然而然，为了加快应用的启动速度，我们可以把 Tomcat 里面的这个功能给关掉。</p>

<h3 id="section-1">方法</h3>

<p>看 Tomcat 的配置文档，关于 Context 的设置这一块，看到了 <code>processTlds</code> 这个属性可以设置，看下这个属性的说明：</p>

<blockquote>
  <p>Whether the context should process TLDs on startup. The default is true. The false setting is intended for special cases that know in advance TLDs are not part of the webapp.</p>
</blockquote>

<p>只要在 Context 中把这个属性设置成 false，那么我们就可以关闭 Tomcat 的 TLD 扫描功能了，为了让所有的应用都可以关闭这个功能，我们可以将 Tomcat 目录下的 conf/context.xml 修改成如下这样：</p>

<p>```
<?xml version='1.0' encoding='utf-8'?>
<context processtlds="false">
    <watchedresource>WEB-INF/web.xml</watchedresource>
</context></p>

<p>```</p>

<h4 id="section-2">坑</h4>

<p>但是，在 Tomcat 6 中测试的时候，发现这个功能没有生效，无奈只能 Debug Tomcat 的源码，发现 StandardContext 的 init 方法下有如下代码：</p>

<p>```
if (processTlds) {
    this.addLifecycleListener(new TldConfig());
}</p>

<p>super.init();</p>

<p>// Notify our interested LifecycleListeners
lifecycle.fireLifecycleEvent(INIT_EVENT, null);
```</p>

<p>这里需要说明的一点是，我们的默认的 context 配置是在 <code>lifecycle.fireLifecycleEvent(INIT_EVENT, null);</code> 这行代码中被处理的，而在这行代码之前，Tomcat 就已经使用了 <code>processTlds</code>，我们的配置完全没有生效。</p>

<h4 id="workaround">Workaround</h4>

<p>那么，这么解决呢？在 context 中，我们还可以配置一个 JarScanner，这个 JarScanner 会被用来扫描 Jar 包中的 tld 文件，我们可以在默认的 context.xml 中配置一个空的 JarScanner，像下面这样：</p>

<p><code>
&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;Context processTlds="false"&gt;
    &lt;JarScanner className="com.alipay.sofa.runtime.test.patch.tomcat.NullJarScanner"/&gt;
&lt;/Context&gt;
</code></p>

<p>NullJarScanner 的代码如下：</p>

<p>```
package com.alipay.sofa.runtime.test.patch.tomcat;</p>

<p>import org.apache.tomcat.JarScanner;
import org.apache.tomcat.JarScannerCallback;</p>

<p>import javax.servlet.ServletContext;
import java.util.Set;</p>

<p>/**
 * @author khotyn 14-1-21 下午4:37
 */
public class NullJarScanner implements JarScanner {
    @Override
    public void scan(ServletContext context, ClassLoader classloader, JarScannerCallback callback, Set<string> jarsToSkip) {
        // Do nothing at all.
    }
}</string></p>

<p>```</p>

<p><strong>需要注意的是，Tomcat 7 不会出现上述的问题，你只要在配置中把 processTlds 设置成 false 即可。</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java 8 之 default method]]></title>
    <link href="http://khotyn.github.com/blog/2014/01/19/java-8-default-method/"/>
    <updated>2014-01-19T22:13:00+08:00</updated>
    <id>http://khotyn.github.com/blog/2014/01/19/java-8-default-method</id>
    <content type="html"><![CDATA[<p>如果进度正常，新版本的 Java，Java 8 将在三月份发布，Java 开发人员期待已久的 lambda 也将在 Java 8 中得到支持。目前，Java 8 的早期版本已经可以在 Java 的网站上下载到了，Intellij IDEA 也已经在其最新的版本支持了 Java 8。所以，最近花了点时间了解了一下 Java 8 中新增加的一些特性。</p>

<p>由于 lambda 的引入，Java 8 对原来的集合类做了大幅的更新，让集合操作可以支持 lambda 表达式。在看新的的集合类的代码的时候，发现了 java 8 似乎增加了一个新的方法描述符，比如在 <code>java.lang.Iterable</code> 里面就新加入了下面这个方法：</p>

<p><code>java
default void forEach(Consumer&lt;? super T&gt; action) {
    Objects.requireNonNull(action);
    for (T t : this) {
        action.accept(t);
    }
}
</code></p>

<p>在方法的最前面，是一个 <code>default</code> 描述符。等等，Iterable 不是个接口吗，怎么有具体的实现代码了？</p>

<p>这个 default 就是在 java 8 中新引入的，它可以让你的接口有一个默认的实现，接口的实现类可以不用去实现 default method，比如，下面这段代码，是可以正常编译通过的：</p>

<p>```java
class Impl implements A {</p>

<p>}</p>

<p>interface A {
    default String foo() {
        return “A”;
    }
}
```</p>

<p>引入 default 的带来的一个好处就是在现有的接口上增加方法而不用让其实现修改代码，通过这种机制，Java 8 可以通过平滑的方式在原有的 Java 的 API 上引入 lambda 的支持。</p>

<p>那么，如果一个类实现了两个接口，这两个接口里面有方法签名相同的 default method，那运行的时候到底会选择哪一个？答案是编译不通过，如果出现这种情况，实现类必须实现 default method，以消除歧义，比如下面这样。</p>

<p>```java
class MultiImpl implements A, B {</p>

<pre><code>/**
 * 由于 A，B 中都有 String foo() 接口，不知道要调用哪个，所以实现类必须实现一下
 *
 * @return
 */
@Override
public String foo() {
    return "C";
} }
</code></pre>

<p>interface A {
    default String foo() {
        return “A”;
    }
}</p>

<p>interface B {
    default String foo() {
        return “B”;
    }
}
```</p>

<p>当然，在的实现类中，也可以直接调用某个接口的 default method：</p>

<p><code>java
class MultiImplInvokeSuper implements A, B {
    @Override
    public String foo() {
        return B.super.foo();
    }
}
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Guava 之 EventBus]]></title>
    <link href="http://khotyn.github.com/blog/2013/12/07/google-guava-eventbus/"/>
    <updated>2013-12-07T19:49:00+08:00</updated>
    <id>http://khotyn.github.com/blog/2013/12/07/google-guava-eventbus</id>
    <content type="html"><![CDATA[<p>Google 的 Guava 库是一个 Java 程序员必须了解的库，它提供了一些非常强大的功能，比如函数式风格的集合操作，Cache Builder 等等的功能，另外 Google Guava 还提供了一个非常方便的观察者模式的实现：EventBus。这篇文章就来介绍一下 EventBus 的使用。</p>

<h3 id="eventbus-">EventBus 对象</h3>

<p>在举例说明 EventBus 的使用方式之前，我们先来看一下 EventBus 对象，EventBus 对象整个负责了观察者模式监听者的注册，事件的分发，所以，在使用 EventBus 的时候，你就省去了非常多的工作，你只要去使用 EventBus 就可以了，不用再去自己实现一个 Publisher 的类，使用 EventBus 的第一步就是你需要一个 EventBus 的实例：</p>

<p><code>java
EventBus eventBus = new EventBus();
</code></p>

<h3 id="section">注册监听者</h3>

<p>使用 EventBus 监听事件，只需要在你的处理事件的方法上添加一个 <code>@Subscribe</code> 注解就可以：</p>

<p><code>java
static class Subscriber {
    @Subscribe
    public void subscribe(Event event) {
        System.out.println(event.getWord());
    }
}
</code></p>

<p>这里的事件对象 <code>Event</code> 可以是任何的对象，可以是 <code>Object</code>，但是也可以是任何你自定义的消息对象。</p>

<p>建立一个类以后，就可以往 EventBus 中注册 Subscriber：</p>

<p><code>java
eventBus.register(new Subscriber());
</code></p>

<h3 id="section-1">分发事件</h3>

<p>在注册完事件后，就可以去分发事件了，分发的代码非常简单：</p>

<p><code>java
eventBus.post(new Event("Hello world"));
</code></p>

<p>这样，所有的注册在 EventBus 中的监听者，只要它的监听方法的参数是 <code>Event</code> 或者 <code>Event</code> 的超类，那么都会收到事件。</p>

<h3 id="section-2">结论</h3>

<p>EventBus 作为一个 In-JVM 的观察者模式的实现，非常使用，使用起来非常简单，可以减少不少的工作，建议在项目中可以多多使用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jvmtop 介绍和实现分析]]></title>
    <link href="http://khotyn.github.com/blog/2013/11/02/jvmtop-impl/"/>
    <updated>2013-11-02T15:36:00+08:00</updated>
    <id>http://khotyn.github.com/blog/2013/11/02/jvmtop-impl</id>
    <content type="html"><![CDATA[<h3 id="section">简介</h3>

<p>jvmtop 是一个分析工具，顾名思义，它是一个针对 jvm 的 工具，展示的方式和 unix 的 top 命令相似。</p>

<p>jvmtop 的项目地址是：<a href="https://code.google.com/p/jvmtop/">jvmtop</a>，安装 jvmtop 除了项目地址上的方式以外，还可以通过 jenv 安装：<code>jenv install jvmtop</code>。</p>

<p>jvmtop 提供了两个视图，一个是概览视图，可以展示出当前机器的所有的 JVM 的情况，命令是 </p>

<p><code>
jvmtop.sh
</code></p>

<p>显示出的信息类似下面这样：</p>

<p><img src="http://pic.yupoo.com/khotyn/DhvVumOY/medish.jpg" alt="image" /></p>

<p>其中，各个字段的意义分别如下：</p>

<ul>
  <li>PID：进程 ID</li>
  <li>MAIN-CLASS：main 类的名字</li>
  <li>HPCUR：当前被使用的 heap 的大小</li>
  <li>HPMAX：最大可用的 heap 的大小</li>
  <li>NHCUR：当前被使用的非 heap 大小（比如：perm gen）</li>
  <li>NHMAX：最大可用的非 heap 大小</li>
  <li>CPU：CPU 的使用情况</li>
  <li>GC：消耗在 GC 上的时间比例</li>
  <li>VM：JVM 的提供者，大版本号，小版本号，图中的意思是 Apple 提供的 JDK 6U51 版本。</li>
  <li>USERNAME：当前的用户名</li>
  <li>#T：线程数量</li>
  <li>DL：是否有现成发生死锁</li>
</ul>

<p>还有一个视图是详情视图，展示一个 JVM 的详细情况，使用的命令如下：</p>

<p><code>
jvmtop.sh &lt;pid&gt;
</code></p>

<p>显示的信息类似下面这样：</p>

<p><img src="http://pic.yupoo.com/khotyn/Dhw0sotX/dTwsh.png" alt="image" /></p>

<p>其中，各个字段的意义如下：</p>

<ul>
  <li>TID：线程 ID</li>
  <li>NAME：线程名</li>
  <li>STATE：线程状态</li>
  <li>CPU：线程当前的 CPU 占用情况</li>
  <li>TOTALCPU：从线程被创建开始总体的 CPU 占用情况</li>
  <li>BLOCKBY：阻塞这个线程的线程 ID</li>
</ul>

<p>更加详细的用法大家可以用下面的用 <code>jvmtop.sh -h</code> 来查看。</p>

<h3 id="section-1">实现</h3>

<p>jvmtop 的实现相对来说还是比较简单的，整个 jvmtop 才 14 个类。</p>

<p><img src="http://pic.yupoo.com/khotyn/DhwgtqPY/IYHUw.png" alt="image" /></p>

<p>其中 JvmTop.java 是入口类。</p>

<p>jvmtop 在启动后，会首先用 <code>sun.jvmstat.monitor.*</code> 下面的类以及 <code>com.sun.tools.attach.VirtualMachine</code> 获取到当前机器的所有的 JVM，然后通过 attachment api 将 <code>management-agent.jar</code> 这个 agent 加载到目标 JVM 上，这样，通过 JMX，就可以拿到当前的 JVM 的各种信息了，具体各个信息需要用什么样的 MBean 去拿，大家可以看对应的源代码。</p>

<p>其实，如果需要一个 JVM 的静态的信息，比如，PID，MAIN-CLASS，JVM-ARGS 等等静态信息，直接用 <code>sun.jvmstat.monitor.*</code> 下的 API 就可以，只有需要动态信息的时候，我们才需要通过 attachment api 把 JMX 的功能打开，通过各种 MBean 去获取这些信息。如果后续需要实现类似的功能，也可以通过这样的思路去做。</p>
]]></content>
  </entry>
  
</feed>
