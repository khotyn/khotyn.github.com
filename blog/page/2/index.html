
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>码工作坊</title>
  <meta name="author" content="khotyn">

  
  <meta name="description" content="此篇文章是作者两年前发布在黄金档的文章。 在上一篇中，我们了解了下 J.U.C 的锁的获取与释放的过程，这个过程主要通过在 A.Q.S 中维持一个等待队列来实现，其中我们也提到了，在 A.Q.S 中除了一个等待队列之外，还有一个 Condition 队列，在了解 Condition 队列之前， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://khotyn.github.com/blog/page/2/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="码工作坊" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body    class="collapse-sidebar sidebar-footer" >
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:khotyn.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
    <li><a href="/">
        <span class="blue_light">
            码工作坊
        </span>
       
    </a></li>
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About me</a></li>
</ul>
</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/12/juc-condition/">Java 并发编程 J.U.C 之 Condition</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-07-12T07:36:00+08:00" pubdate data-updated="true">Jul 12<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/07/12/juc-condition/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><strong>此篇文章是作者两年前发布在<a href="http://www.goldendoc.org/2011/06/juc_condition/">黄金档</a>的文章。</strong></p>

<p>在上一篇中，我们了解了下 <a href="http://blog.khotyn.com/blog/2013/07/10/juc-lock-acquire-release/">J.U.C 的锁的获取与释放的过程</a>，这个过程主要通过在 A.Q.S 中维持一个等待队列来实现，其中我们也提到了，在 A.Q.S 中除了一个等待队列之外，还有一个 Condition 队列，在了解 Condition 队列之前，先来看一下 Condition 是怎么回事：</p>

<blockquote><p>The synchronizer framework provides a ConditionObject class for use by synchronizers that maintain exclusive synchronization and conform to the Lock interface. Any number of condition objects may be attached to a lock object, providing classic monitor-style await, signal, and signalAll operations, including those with timeouts, along with some inspection and monitoring methods.</p></blockquote>

<p>上面的这一段内容摘自 Doug Lea 的 <a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf">AQS 论文</a>，从上面这一段话可以看出，Condition 主要是为了在 J.U.C 框架中提供和 Java 传统的监视器风格的 wait，notify 和 notifyAll 方法类似的功能，那么先来解释一下这三个方法的作用：</p>

<ul>
<li>Object.wait() 方法：使当前线程释放 Object 上的监视器并且挂起，直到有另外的线程调用 Object.notify() 方法或者 Object.notifyAll() 方法唤醒当前线程，当被唤醒后，Object.wait() 方法会尝试重新获取监视器，成功获取后继续往下执行。注意 Object.wait() 方法只有在当前线程持有 Object 的监视器的时候才能够调用，不然会抛出异常。</li>
<li>Object.notify() 方法：用于唤醒另外一个调用了 Object.wait() 方法的线程，如果有多个都调用了 Object.wait() 方法，那么就会选择一个线程去 notify()，具体选择哪一个和具体的实现有关，当前线程在调用 Object.notify() 方法以后会就释放Object的监视器，和 wait() 方法一样，Object.notify() 方法只有在当前线程持有 Object 的监视器的时候才能够调用，不然就会抛出异常。</li>
<li>Object.notifyAll() 方法：唤醒所有调用了 Object.wait() 方法的线程，如果有多个线程调用了 Object.wait() 方法，那么就会引发这些线程之间的竞争，最后谁成功获取到 Object 的监视器和具体的实现有关，当前线程在调用 Object.notifyAll() 方法以后会就释放 Object 的监视器，和 wait() 方法一样，Object.notifyAll() 方法只有在当前线程只有 Object 的监视器的时候才能够调用，不然就会抛出异常。</li>
</ul>


<p>那么 Condition 是如何实现 wait，notify 和 notifyAll 方法的功能呢？我们接下来看：</p>

<p>在 Condition 中，wait，notify 和 notifyAll 方法分别对应了 await，signal 和 signalAll 方法，当然 Condition 也提供了超时的、不可被中断的 await() 方法，不过我们主要还是看一看 await，notify 和 notifyAll 的实现，先看 await：</p>

<h3>await 方法</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">await</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">interrupted</span><span class="o">())</span>
</span><span class='line'>        <span class="k">throw</span> <span class="k">new</span> <span class="nf">InterruptedException</span><span class="o">();</span>
</span><span class='line'>    <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">addConditionWaiter</span><span class="o">();</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">savedState</span> <span class="o">=</span> <span class="n">fullyRelease</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">interruptMode</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="k">while</span> <span class="o">(!</span><span class="n">isOnSyncQueue</span><span class="o">(</span><span class="n">node</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">LockSupport</span><span class="o">.</span><span class="na">park</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">((</span><span class="n">interruptMode</span> <span class="o">=</span> <span class="n">checkInterruptWhileWaiting</span><span class="o">(</span><span class="n">node</span><span class="o">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
</span><span class='line'>            <span class="k">break</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">acquireQueued</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">savedState</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">interruptMode</span> <span class="o">!=</span> <span class="n">THROW_IE</span><span class="o">)</span>
</span><span class='line'>        <span class="n">interruptMode</span> <span class="o">=</span> <span class="n">REINTERRUPT</span><span class="o">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">nextWaiter</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>        <span class="n">unlinkCancelledWaiters</span><span class="o">();</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">interruptMode</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
</span><span class='line'>        <span class="n">reportInterruptAfterWait</span><span class="o">(</span><span class="n">interruptMode</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>整个 await 的过程如下：</p>

<ul>
<li>在第 2 行处，如果当前线程被中断，则抛出中断异常。</li>
<li>在第 4 行处，将节点加入到 Condition 队列中去，这里如果 lastWaiter 是 cancel 状态，那么会把它踢出 Condition 队列。</li>
<li>在第 5 行处，调用 tryRelease，释放当前线程的锁</li>
<li>在第 7 行处，判断节点是否在等待队列中（signal 操作会将 Node 从 Condition 队列中拿出并且放入到等待队列中去），如果不在等待队列中了，就 park 当前线程，如果在，就退出循环，这个时候如果被中断，那么就退出循环</li>
<li>在第 12 行处，这个时候线程已经被 signal() 或者 signalAll() 操作给唤醒了，退出了 4 中的 while 循环，尝试再次获取锁，调用 acquireQueued 方法。</li>
</ul>


<p>可以看到，这个 await 的操作过程和 Object.wait() 方法是一样，只不过 await() 采用了 Condition 队列的方式实现了 Object.wait() 的功能。</p>

<h3>signal 和 signalAll 方法</h3>

<p>在了解了 await 方法的实现以后，signal 和 signalAll 方法的实现就相对简单了，先看看 signal 方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">signal</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(!</span><span class="n">isHeldExclusively</span><span class="o">())</span>
</span><span class='line'>        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalMonitorStateException</span><span class="o">();</span>
</span><span class='line'>    <span class="n">Node</span> <span class="n">first</span> <span class="o">=</span> <span class="n">firstWaiter</span><span class="o">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">first</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>        <span class="n">doSignal</span><span class="o">(</span><span class="n">first</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里先判断当前线程是否持有锁，如果没有持有，则抛出异常，然后判断整个 condition 队列是否为空，不为空则调用 doSignal 方法来唤醒线程，看看 doSignal 方法都干了一些什么：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kt">void</span> <span class="nf">doSignal</span><span class="o">(</span><span class="n">Node</span> <span class="n">first</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">do</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span> <span class="o">(</span><span class="n">firstWaiter</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">nextWaiter</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>            <span class="n">lastWaiter</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="n">first</span><span class="o">.</span><span class="na">nextWaiter</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">while</span> <span class="o">(!</span><span class="n">transferForSignal</span><span class="o">(</span><span class="n">first</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
</span><span class='line'>             <span class="o">(</span><span class="n">first</span> <span class="o">=</span> <span class="n">firstWaiter</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个 while 循环的作用就是将 firstWaiter 往 Condition 队列的后面移一位，并且唤醒 first，看看 while 循环中 tranferForSignal：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">transferForSignal</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="cm">/*</span>
</span><span class='line'><span class="cm">     * If cannot change waitStatus, the node has been cancelled.</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(!</span><span class="n">compareAndSetWaitStatus</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">Node</span><span class="o">.</span><span class="na">CONDITION</span><span class="o">,</span> <span class="mi">0</span><span class="o">))</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/*</span>
</span><span class='line'><span class="cm">     * Splice onto queue and try to set waitStatus of predecessor to</span>
</span><span class='line'><span class="cm">     * indicate that thread is (probably) waiting. If cancelled or</span>
</span><span class='line'><span class="cm">     * attempt to set waitStatus fails, wake up to resync (in which</span>
</span><span class='line'><span class="cm">     * case the waitStatus can be transiently and harmlessly wrong).</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="n">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">enq</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">waitStatus</span><span class="o">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">compareAndSetWaitStatus</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">Node</span><span class="o">.</span><span class="na">SIGNAL</span><span class="o">))</span>
</span><span class='line'>        <span class="n">LockSupport</span><span class="o">.</span><span class="na">unpark</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">thread</span><span class="o">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这段代码的作用就是修改 Node 的 waitStatus 为 0，然后将 Node 插入到等待队列中，并且唤醒 Node。</p>

<p>signalAll 和 signal 方法类似，主要的不同在于它不是调用 doSignal 方法，而是调用 doSignalAll 方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kt">void</span> <span class="nf">doSignalAll</span><span class="o">(</span><span class="n">Node</span> <span class="n">first</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">lastWaiter</span> <span class="o">=</span> <span class="n">firstWaiter</span>  <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="k">do</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Node</span> <span class="n">next</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">nextWaiter</span><span class="o">;</span>
</span><span class='line'>        <span class="n">first</span><span class="o">.</span><span class="na">nextWaiter</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="n">transferForSignal</span><span class="o">(</span><span class="n">first</span><span class="o">);</span>
</span><span class='line'>        <span class="n">first</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">first</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个方法就相当于把 Condition 队列中的所有 Node 全部取出插入到等待队列中去。</p>

<h3>总结</h3>

<p>在了解了 await，signal 和 signalAll 方法的实现以后，我们再来通过一副 gif 动画来看一看这一个整体的过程：</p>

<p><img src="http://farm3.staticflickr.com/2888/9263654699_6b959eecb2_o.gif" alt="image" /></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/10/juc-lock-acquire-release/">Java 并发编程 J.U.C 之锁的获取与释放</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-07-10T20:14:00+08:00" pubdate data-updated="true">Jul 10<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/07/10/juc-lock-acquire-release/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><strong>此篇文章是作者两年前发表在<a href="http://www.goldendoc.org/2011/06/lock_acquire_release/">黄金档</a>的文章。</strong></p>

<p>上一篇文章中，我们对 <a href="http://www.goldendoc.org/2011/05/juc/">J.U.C 的一些大概的情况</a>做了了解，在这一篇文章我们将来以 ReentrantLock 为例，来分析一下锁的获取和释放的过程，让大家能够对锁的获取和释放的整体过程有一个了解。</p>

<h3>一、锁的获取</h3>

<p>先看下 ReentrantLock 的 lock() 方法，整个方法只有一行，调用 acquire 方法，看看 acquire 方法的实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">acquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(!</span><span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
</span><span class='line'>        <span class="n">acquireQueued</span><span class="o">(</span><span class="n">addWaiter</span><span class="o">(</span><span class="n">Node</span><span class="o">.</span><span class="na">EXCLUSIVE</span><span class="o">),</span> <span class="n">arg</span><span class="o">))</span>
</span><span class='line'>        <span class="n">selfInterrupt</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这段代码的实现也是比较简洁，先尝试一次 tryAcquire 操作，如果失败，则把当前线程加入到同步队列中去，这个时候可能会反复的阻塞与唤醒这个线程，直到后续的 tryAcquire（看 acquireQueued 的实现）操作成功。</p>

<p>再看看 tryAcquire 的实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">acquires</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">final</span> <span class="n">Thread</span> <span class="n">current</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">();</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">isFirst</span><span class="o">(</span><span class="n">current</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
</span><span class='line'>            <span class="n">compareAndSetState</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">acquires</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="n">current</span><span class="o">);</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="n">getExclusiveOwnerThread</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">nextc</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">acquires</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">nextc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">Error</span><span class="o">(</span><span class="s">&quot;Maximum lock count exceeded&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="n">setState</span><span class="o">(</span><span class="n">nextc</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这段代码是尝试获取锁的过程，它先判断当前的 AQS 的 state 值，如果为 0，则表示该锁没有被持有过，如果这个时候同步队列是空的或者当前线程就是在同步队列的头部，那么修改 state 的值，并且设置排他锁的持有线程为当前线程</p>

<p>如果大于 0，则判断当前线程是否是排他锁的持有线程，如果是，那么把 state 值加 1（注意 state 是 int 类型的，所以 state 的最大值是就是 int 的最大值）</p>

<p>如果第一次 tryAcquire() 操作失败，那么就把当前线程加入到等待队列中去，看 addWaiter() 方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="n">Node</span> <span class="nf">addWaiter</span><span class="o">(</span><span class="n">Node</span> <span class="n">mode</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">(),</span> <span class="n">mode</span><span class="o">);</span>
</span><span class='line'>    <span class="c1">// Try the fast path of enq; backup to full enq on failure</span>
</span><span class='line'>    <span class="n">Node</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">pred</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">pred</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetTail</span><span class="o">(</span><span class="n">pred</span><span class="o">,</span> <span class="n">node</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">enq</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这段代码中先尝试了一下了下 enq() 方法中等待队列不为空的情况，如果失败，再调用 enq() 方法将当前线程加入等待队列，enq() 的过程我们已经在上一篇文章中讲过了，不再赘述。</p>

<p>最后在当前线程被加入到等待队列中去以后，再调用 acquireQueued 去获取锁，看看 acquireQueued 的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">acquireQueued</span><span class="o">(</span><span class="kd">final</span> <span class="n">Node</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">boolean</span> <span class="n">interrupted</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
</span><span class='line'>            <span class="kd">final</span> <span class="n">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">predecessor</span><span class="o">();</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">head</span> <span class="o">&amp;&amp;</span> <span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">setHead</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
</span><span class='line'>                <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// help GC</span>
</span><span class='line'>                <span class="k">return</span> <span class="n">interrupted</span><span class="o">;</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">shouldParkAfterFailedAcquire</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">node</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
</span><span class='line'>                <span class="n">parkAndCheckInterrupt</span><span class="o">())</span>
</span><span class='line'>                <span class="n">interrupted</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">RuntimeException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">cancelAcquire</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
</span><span class='line'>        <span class="k">throw</span> <span class="n">ex</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这段代码中拿到当前线程在同步队列中的前面一个节点，如果这个节点是是头部，那么马上进行一次 tryAcquire 操作，如果操作成功，那么把当前线程弹出队列，整个操作就此结束。如果这个节点不是头部或者说 tryAcquire 操作失败的话，那么就判断是不是要将当前线程给阻塞掉（shouldParkAfterFailedAcquire）方法：判断当前线程是否应该被阻塞掉，实际上判断的是当前线程的前一个节点的状态，如果前一个节点的状态小于 0（condition 或者 signal），那么返回 true，阻塞当前线程；如果前一个节点的状态大于 0（cancelled），则向前遍历，直到找到一个节点状态不大于 0 的节点，并且将中间的 cancelled 状态的节点全部踢出队列；如果前一个节点的状态等于 0，那么将其状态置为 -1（signal），并且返回 false，等待下一次循环的时候再阻塞。</p>

<p><strong>整个锁的获取过程就是这样，我们再来总结一下整个过程</strong>：acquire() 方法会先调用一次 tryAcquire 方法获取一次锁，如果失败，则把当前线程加入到等待队列中去，然后再调用 acquireQueued 获取锁，acquireQueued 在当前节点不在头部的时候会把当前线程的前一个结点的状态置为 SIGNAL，然后阻塞当前线程。当当前线程到了队列的头部的时候，那么获取锁的操作就会成功返回。</p>

<h3>二、锁的释放</h3>

<p>首先，我们知道在 acquireQueued 方法中，如果一个线程成功获取到了锁，那么它就应该是整个等待队列的 head 节点，然后，我们再来看一看 unlock() 方法，和 lock() 方法一样，unlock() 方法也是只有一行代码，直接调用 release() 方法，我们看看 release() 方法的实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">release</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">tryRelease</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Node</span> <span class="n">h</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">h</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
</span><span class='line'>            <span class="n">unparkSuccessor</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个过程首先调用 tryRelease 方法，如果锁已经完全释放，那么就唤醒下一个节点，先来看看 tryRelease 方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryRelease</span><span class="o">(</span><span class="kt">int</span> <span class="n">releases</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">()</span> <span class="o">-</span> <span class="n">releases</span><span class="o">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">()</span> <span class="o">!=</span> <span class="n">getExclusiveOwnerThread</span><span class="o">())</span>
</span><span class='line'>        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalMonitorStateException</span><span class="o">();</span>
</span><span class='line'>    <span class="kt">boolean</span> <span class="n">free</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">free</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">setState</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">free</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这段代码首先获取当前 AQS 的 state 状态并且将其值减一，如果结果等于 0（锁已经被完全释放），那么将排他锁的持有线程置为 null。将 AQS 的 state 状态置为减一后的结果。</p>

<p>然后再看看唤醒继任节点的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kt">void</span> <span class="nf">unparkSuccessor</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">compareAndSetWaitStatus</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">Node</span><span class="o">.</span><span class="na">SIGNAL</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
</span><span class='line'>    <span class="n">Node</span> <span class="n">s</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">s</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="n">Node</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span> <span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">node</span><span class="o">;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">prev</span><span class="o">)</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span>
</span><span class='line'>                <span class="n">s</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>        <span class="n">LockSupport</span><span class="o">.</span><span class="na">unpark</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">thread</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这段代码先清除当前节点的 waitStatus 为 0，然后判断下一个节点是不是 null 或者 cancelled 的状态，如果是，则从队列的尾部往前开始找，找到一个非 cancelled 状态的节点，最后唤醒这个节点。</p>

<p><strong>最后，总结一下释放操作的整个过程</strong>：其实整个释放过程就做了两件事情，一个是将state值减1，然后就是判断锁是否被完全释放，如果被完全释放，则唤醒继任节点。</p>

<h3>三、整体过程描述</h3>

<p>看了上面的锁的获取与释放操作以后，整体过程还是比较清晰的，在文章的最后，我们把获取与释放操作串在一起在简单看一下：</p>

<ul>
<li>获取锁的时候将当前线程放入同步队列，并且将前一个节点的状态置为 signal 状态，然后阻塞</li>
<li>当这个节点的前一个节点成功获取到锁，前一个节点就成了整个同步队列的 head。</li>
<li>当前一个节点释放锁的时候，它就唤醒当前线程的这个节点，然后当前线程的节点就可以成功获取到锁了</li>
<li>这个时候它就到整个队列的头部了，然后 release 操作的时候又可以唤醒下一个。</li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/07/10/bash-job-control/">Bash Job Control</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-07-10T19:43:00+08:00" pubdate data-updated="true">Jul 10<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/07/10/bash-job-control/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这两天在给 <a href="https://github.com/khotyn/hotcode">HotCode</a> 写<a href="https://github.com/khotyn/hotcode/blob/master/test.sh">测试脚本</a>，其中用到了 Bash 的任务控制功能，说白了就是把一个任务放到后台，拉到前台之类的操作，这里做一下总结。</p>

<h3>开启任务控制</h3>

<p>首先，如果要在 Bash 脚本中使用 Bash 的任务控制功能，必须先执行下面这个命令：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">set</span> -m
</span></code></pre></td></tr></table></div></figure>


<p>这个命令的意思其实就是开启 Bash 的任务控制功能，见 Bash Manual 的 <a href="https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html">The Set Buildin</a>。</p>

<h3>把任务放到后台执行</h3>

<p>要把任务放到后台非常容易，只要在命令后面加入一个 <code>&amp;</code> 即可，像这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>bash test.sh &amp;
</span></code></pre></td></tr></table></div></figure>


<p>命令的输出类似于这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="o">[</span>1<span class="o">]</span> 51668
</span></code></pre></td></tr></table></div></figure>


<p>其中前面的 <code>[1]</code> 代表的是这个任务的任务编号，而 <code>51668</code> 则是这个任务的进程 ID。</p>

<h3>查看在后台执行的任务的执行情况</h3>

<p><code>jobs</code> 命令可以查看在后台执行的任务的情况</p>

<p>它的输出类似于下面这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="o">[</span>1<span class="o">]</span>  + running    bash test.sh
</span></code></pre></td></tr></table></div></figure>


<p>前面的 <code>[1]</code> 就是任务编号，后面的 <code>running</code> 表示任务当前运行的状态。</p>

<p><code>jobs</code> 命令后面可以加一些参数，比如下面这些：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">jobs</span> -r <span class="c">###只输出正在运行的任务</span>
</span><span class='line'><span class="nb">jobs</span> -s <span class="c">###只输出已经执行完的任务</span>
</span></code></pre></td></tr></table></div></figure>


<p>具体看 <a href="https://www.gnu.org/software/bash/manual/html_node/Job-Control-Builtins.html#Job-Control-Builtins">Job Control Buildins</a>。</p>

<h3>把任务调度到前台</h3>

<p>要把任务调度到前台只要用 <code>fg</code> 命令就可以，后面加上一个任务编号表示要把哪个后台任务调度到前台：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">fg</span> %1
</span></code></pre></td></tr></table></div></figure>


<p>上面这个命令就是把任务编号为 1 的任务调度到前台。</p>

<p>Bash 的任务调度还是比较简单的，不过的确是非常地有用。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/06/21/4clojure/">成就达成：4clojure 题目全破！</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-06-21T22:09:00+08:00" pubdate data-updated="true">Jun 21<span>st</span>, 2013</time>
        
         | <a href="/blog/2013/06/21/4clojure/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>经过了一个多月的努力，终于将 <a href="http://www.4clojure.com/">4clojure.com</a> 上面的的题目全部解出了，经过这段时间不断地用 clojure，对 Clojure 也有了一些基本的认识，目前让我觉得 clojure 强大的地方在于：</p>

<ul>
<li>和命令式语言完全不同的编程方式，编程过程就像是不断地数据转换的过程，它给你的感觉就像是进入了一个完全不同的世界一样。</li>
<li>“惰性求值 + 无限序列”很好很强大~，比如在产生斐波那契数列或者是素数序列的时候都非常有用。</li>
</ul>


<p>也说说几点不满意的地方：</p>

<ul>
<li>括号比较多，不过这个也是没有办法，有良好的编译器的话这个问题也不算是问题啦。</li>
<li>异常比较难看懂，不知道是不是我是新手的原因，觉得 clojure 的异常不容易懂，clojure 的代码里面常常一行包括非常多的代码，做了很多的事情，单单看异常还看不错出错的地方在哪里。</li>
</ul>


<p>总之，经过这段时间在 <a href="http://www.4clojure.com/">4clojure.com</a> 上的学习，算是对 clojure 的基本语法，核心函数等东西有了一个基本的掌握，后面会尝试用 clojure 做一些实际的东西，至于做什么，还没有想好。</p>

<p>另外，我已经将我的 4clojure 题目的答案都放到了 github 上，地址是：<a href="https://github.com/khotyn/4clojure-answer">https://github.com/khotyn/4clojure-answer</a>， 如果大家在解题的过程中遇到了什么困难，可以看看我的答案，当然，我的很多答案都是有臭又长，大家有更精简的答案欢迎一起交流。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/05/12/gongga-hiking-part-two/">贡嘎全线徒步穿越 &#8211; Part Two</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-05-12T21:24:00+08:00" pubdate data-updated="true">May 12<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/05/12/gongga-hiking-part-two/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>贡嘎全线穿越第一篇见：<a href="http://blog.khotyn.com/blog/2013/05/07/gongga-hiking-part-one/">http://blog.khotyn.com/blog/2013/05/07/gongga-hiking-part-one/</a></p>

<h3>Day Four</h3>

<p>昨晚睡得非常舒服，一扫了昨日的疲惫，可是天公不作美，山上的云看起来很厚，有点担心今天能否看到贡嘎主峰。一行人吃过了早餐（那个饼子在烤过以后非常好吃，不过忘记了叫什么名字）便搭车前往子梅垭口了，车子到了海拔 4400 米的地方便上不去了，上面全是雪，今天我和其他的几个打算在子梅垭口露营的人背的都是重装，到子梅垭口 200 米的海拔走起来还是有点累的，到达子梅垭口的时候能见度已经非常地差了，人稍微站远一点就看不到了，在子梅垭口待了一会儿，我们又遇到了昨天的那两个重装的哥们了，那两个哥们昨天就已经上来了，没有看到贡嘎主峰，然后下山了，今天又上来了，还是没有看到，只能说运气真不好。</p>

<p><img src="http://pic.yupoo.com/khotyn/CR5hnMdS/medish.jpg" alt="image" /></p>

<p>因为今天的风比较大，所以我们只能选择了在老子梅垭口扎营，老子梅垭口离子梅垭口大概有几百米的路程，那个有一个小木屋，挡风很好，我们把帐篷搭载了小木屋的里面，木屋里面还有一些木头，领队小胖把木头砸碎，准备生个火出来给大家暖和暖和，这时候，来了一个藏族人，看到我们整准备取火，便说那些木头是他的，不能烧，我们很无奈，只能表示不烧了，接着他又表示：“这些木头不是我的，也不是书记的，这些木头是贡嘎寺的，任何人向你们要钱，你们千万都不能给。我理解你们现在挺冷的，烧一点也是可以的，大家要相互理解嘛，但是不能烧太多。”，我们听了以后很无奈，只能连声称是。</p>

<p><img src="http://pic.yupoo.com/khotyn/CR5jdI0N/medish.jpg" alt="image" /></p>

<p>火烧起来以后驱走了不少的寒气，手脚都暖和了许多，外面已经开始下雪，能见度还是很低，老驴米兰给我们讲了他去过的一些地方：格列，木里，七藏沟，年保玉则，稻城，亚丁，雨崩等地方，还给我们看了很多照片，真美，不过四川这边的山水大多数秋天的时候最美，要全部都走一边得花好几年呢。</p>

<p><img src="http://pic.yupoo.com/khotyn/CR5n04ZN/medish.jpg" alt="image" /></p>

<h3>Day Five</h3>

<p>昨晚睡得非常难受，头都快爆炸了，在海拔 4600 的地方露营果然是自找麻烦。早上起来，外面的天气没有丝毫地好转，昨晚下了一晚上的雪，路上的脚印已经消失地无影无踪了，不知道下山的路还能不能找到了。简单地吃过早餐，领队小胖开始出去找路，其实只要找到公路就好，顺着公路下山就可以，过了大约 20 分钟，小胖成功找到了公路的位置，我们顺着他的脚印走下去，每走一步雪都没到了膝盖。</p>

<p><img src="http://pic.yupoo.com/khotyn/CR5pRNsJ/medish.jpg" alt="image" /></p>

<p>到了公路后几个人发疯似地往下狂走，深怕这么大的雪下不去到底该怎么办，到了海拔 4100 米左右的地方，视野还是开阔起来，另我们惊奇的是，虽然没有看到贡嘎主峰，但是这雪后的雪山景色也是非常美丽的，让人感觉到真是不虚此行。</p>

<p><img src="http://pic.yupoo.com/khotyn/CR5rkaaF/medish.jpg" alt="image" /></p>

<p>再往下走就到了上子梅村，这个村子比我想象中地要小很多，只有三户人家，不过坐落在世外桃源里面，也算是不错了。</p>

<p><img src="http://pic.yupoo.com/khotyn/CR5sy9rW/medish.jpg" alt="image" /></p>

<p>可能是早上下山的路走地太急，费了不少地体力，下午从上子梅村走到下子梅村的时候有点累，快到下子梅的时候路过一个小学：“驴爱次梅小学”，我们的前面说到的陈老师就在这里面教书。见到陈老师比我想象中的要年轻，聊过以后知道他是 90 年的，今年只有 23 岁，去年刚刚大学毕业，本想只是跑到这边来看一看的，没想到竟然走不成了。这边官方没有小学，想要上小学就只能走很多的路到镇里面去，这个时候住宿是最好的选择，但是很多藏民一年的收入并不能负担起孩子的住宿费用，所以就只能让孩子辍学了。问起他在这里工作生活地一些困难，他说一个是冬天食物不足，这个小山村走出去得一天的时间，小孩子们的课又不能不少，他冬天食物最匮乏的时候曾经抓老鼠吃；另一个就是书记和村长对他的工作不支持，刚开始书记和村长还以为他是来搞投资的，因为在他们的观念里面，一个人不可能无缘无故地就跑到这么个偏僻的地方教书。书记和村长的孩子们都在外面读书，他们不怎么关心其他本村的孩子的教育情况。其实也有很多人对这里的教育进行资助，但是很多善款都被书记和村长贪掉了。这么偏僻的地方其实最缺的就是老师，一个老师一走，学校也就关了。</p>

<p><img src="http://pic.yupoo.com/khotyn/CR5xGkrX/medish.jpg" alt="image" /></p>

<p>晚上，我们邀请了陈老师来和我们一起吃饭，看他吃饭的样子应该是经常受饥饿的，有那种对食物的渴望在。因为第二天就要出去了，所以我们给自己剩了一天的路粮，其他的食物就给陈老师了，希望尽一点自己的绵薄之力。</p>

<p><img src="http://pic.yupoo.com/khotyn/CR5yLZi4/medish.jpg" alt="image" /></p>

<h3>Day Six</h3>

<p>昨晚也睡得很好，不用露营真是太好了，今天早上天气很不错，可是我只能在心里暗骂好天气为什么不早一天到来呢，为了看到贡嘎主峰，我一定要再来一次贡嘎全线穿越。</p>

<p>今天已经是徒步的最后一天了，行程相对比较轻松，我们乘拖拉机到了巴望海（这边的人叫湖为海子，做拖拉机屁股快被颠成两半儿了），本来巴望海也是一个拥有很美景色的地方，但是那些美景只会在秋天才能出现。走过了巴望海，我们徒步走到了界碑石，然后坐车到了草科镇。</p>

<p><img src="http://pic.yupoo.com/khotyn/CR5Ddhlj/medish.jpg" alt="image" /></p>

<p>到草科以后总算是有信号了，赶紧给家里打了电话，住的地方有温泉，吃过晚饭以后泡了一个温泉非常舒服，之后，作为徒步的最后一天，大家一起吃了夜宵，聊得很 High。</p>

<h3>Day Seven</h3>

<p>今天一大早起来，从草科坐车到成都，路途比想象中要顺利，只花了三个小时。中午去九眼桥吃了滋味烤鱼，很不一样的滋味，很好吃，这半的烤鱼烤地很嫩，不像杭州的烤鱼，皮都是焦的。</p>

<p><img src="http://pic.yupoo.com/khotyn/CR5F31iM/medish.jpg" alt="image" /></p>

<p>下午到四川大学逛了一下，里面有一些学生正准备搭车去四川，很有想法。</p>

<p>晚上坐飞机飞回了杭州，飞机晚点，到达杭州已是半夜两点钟。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/05/09/clojure-element-in-seq/">Clojure 如何判断一个序列中是否存在某个元素</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-05-09T21:17:00+08:00" pubdate data-updated="true">May 9<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/05/09/clojure-element-in-seq/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近一直在看 Clojure，经常碰到的一个问题是怎么判断一个序列中是否存在某个元素。对于这个问题的第一反应就是用<code>contains?</code>来判断，但是<code>contains?</code>的第二个参数是<code>key</code>而不是元素的值，对于 vector 或者 array 这样的数据结构不能做判断：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">user</span><span class="o">=</span>&gt; <span class="o">(</span>contains? <span class="err">&#39;</span><span class="o">(</span>101 102 103 104<span class="o">)</span> 101<span class="o">)</span>
</span><span class='line'><span class="nb">false</span>
</span></code></pre></td></tr></table></div></figure>


<p>另一个方法就是采用 set 配合 some 来做判断：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">user</span><span class="o">=</span>&gt; <span class="o">(</span>some <span class="c">#{101} &#39;(101 102 103 104))</span>
</span><span class='line'>101
</span></code></pre></td></tr></table></div></figure>


<p><code>some</code> 的函数原型是 <code>(some prev coll)</code>，它会对 coll 中的元素依次应用 prev 进行测试，返回第一个为真的元素，而用一个 set 进行测试，返回就是第一个包含在这个 set 中的元素，因此上面的那段表达式就返回了 101。</p>

<p>这样，只要上面这个表达式返回的不是<code>nil</code>，就表示元素在序列中了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/05/07/gongga-hiking-part-one/">贡嘎全线徒步穿越 &#8211; Part One</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-05-07T22:13:00+08:00" pubdate data-updated="true">May 7<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/05/07/gongga-hiking-part-one/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>清明节在家宅了三天，非常地不舒服，某日在内网看到了贡嘎徒步的召集贴，脑袋一热就报名了，前期买了很多的装备，做了一些准备，期间还四川还发生了地震，差点退缩了，不过最后还是出发了。</p>

<h3>Day One</h3>

<p>前一天从杭州飞到成都，一大早从成都出发，海拔一路上升，到康定进行了一些补给，到了一个叫老榆林的村庄，海拔 3200 米，住在藏人扎西的家里，这边的房子充满了藏族风情，刚进村子就看到了雪山，真的是非常地壮观。</p>

<p><img src="http://pic.yupoo.com/khotyn/CQjRiogI/medish.jpg" alt="image" /></p>

<p>扎西的家的下面就有一条小河穿过，河旁边有几个天然的温泉，其中一个温泉里面，一个女人裸露着上半身带着儿子在洗澡，我们也下到旁边的温泉里面泡脚，温泉充满了硫磺的味道，不过泡地非常地舒服。</p>

<p><img src="http://pic.yupoo.com/khotyn/CQjKjley/medish.jpg" alt="image" /></p>

<p>为了防止高反，领队小胖让我们喝了很多的水，半夜上了好几趟厕所，据说他们爬山的时候有时候就直接拿着喝水的瓶子解决，第二天再用雪水洗洗继续用，非常时刻，非常措施。</p>

<h3>Day Two</h3>

<p>今天正式开始徒步，车子将我们送到了电站，在电站碰到了好多藏人正准备进山挖虫草，现在正是藏人挖虫草的季节，虫草是很多家庭一年唯一的收入。从电站出发到格西草原，一路上很有指环王、魔兽世界的感觉，在森林、灌木中行走，让我怀疑自己是不是身在希尔斯布莱德丘陵，路旁还不时有一些旄牛在吃草，有几只旄牛仔很可爱。</p>

<p><img src="http://pic.yupoo.com/khotyn/CQjVaIYI/medish.jpg" alt="image" /></p>

<p>中午的时候队伍到达了盘盘山垭口的下方，海拔大概在 3800 米，下面是一个非常陡的坡，我们的目的地是 4200 米的露营地，爬坡比想象中的累很多，用了领队的方法，调正呼吸，尽量用深呼吸，放慢自己所有的动作，跟随自己的节奏，不要跟随别人的脚步，才轻松了不少，上了 4000 米以后就完全是另外的一番景象了，没有了森林，也没有了灌木，只有高山草甸。因为是个纯爷们儿的队伍，队伍的行进速度比想象中的要快，在下午三点左右，我们就到达了预计的露营地，看大家体力还不错，就继续开始攀爬，大概下午四点左右的时候到达了 4300 米出的营地，然后开始扎营，后面看来这可能是个错误的决定，最后的这一百米的海拔消耗了大家很多的体力，到达营地搭完帐篷后，每个人都累得不行了，有几个队友还出现了比较严重的高反，头痛地厉害，特别是影风，喊着第二天要回去，实在受不了，我也稍微有点头痛，不过还是可以忍受。</p>

<p>在我们扎营的时候，后面来了两个重装的哥们，没有向导，背后的登山包叠地高高的，好生佩服，他们选择了在我们旁边扎营，大家在一起好照顾嘛。</p>

<p>傍晚的时候天气开始剧变，下方山谷里面的雾气扑面而来，不一会儿，就开始下雪了，帐篷上开始积雪，领队阿甘还在给我们做饭。吃完饭已经是天黑，雪还在继续地下，庆幸的是下的不是雨，要不然还得在帐篷旁边挖倒水沟什么的，麻烦地很。</p>

<p><img src="http://pic.yupoo.com/khotyn/CQjZrq7a/medish.jpg" alt="image" /></p>

<p>吸取了昨天喝了太多的水，半夜得起来好几趟的教训，今天晚上没有喝水，毕竟睡在帐篷里面解决起来可不是很方便啊。</p>

<h3>Day Three</h3>

<p>昨晚一夜没有睡好，不知道到底睡了几个小时，头胀的厉害，口也很喝，真是难受，这一夜特别漫长。</p>

<p>等了很久的样子，感觉天亮啊，打开帐篷一看，啊，满眼是雪，抬头一看，天气好极了，周围雪山的轮廓也清晰极了。</p>

<p><img src="http://pic.yupoo.com/khotyn/CQjYdYbh/medish.jpg" alt="image" /></p>

<p>天空还挂了半轮月亮，太阳，月亮，蓝天，雪山，都一起出现了，看到这美景，身上的疲惫都感觉少了一大半了。</p>

<p><img src="http://pic.yupoo.com/khotyn/CQk0Ulwk/medish.jpg" alt="image" /></p>

<p>早餐大家都没有胃口，喝了一点粥，领队切了很多饼子，大部分都没有吃完。昨天两个重装的哥们已经开始向盘盘山垭口进发，我们收拾好东西随后也进发了。</p>

<p>到盘盘山垭口的路不是很艰难，照样是昨天的方法，在中午左右我们就达到盘盘山垭口了，天气目前也还可以，可惜小贡嘎被云挡住了，希望后面爬子梅垭口的时候可以看到贡嘎主峰。</p>

<p><img src="http://pic.yupoo.com/khotyn/CQk41ndU/medish.jpg" alt="image" /></p>

<p>到达盘盘山垭口，拍了几个照片，发现前面重装的哥们走错路了，领队告诉了他们正确的路，估计他们得多花几个小时走路了，从盘盘山垭口下去一路是下坡，走起来也轻松了很多，不过下山达到山谷后就要开始走土路，下午走了好几个小时，脚就开始痛了，毕竟，登山鞋不适合走这种路，今天本想走到差不多了就在路边扎营的，领队小胖看我们已经非常疲惫，于是骑马到有手机信号的地方叫来了车子，帮我们直接送到了玉龙西村。</p>

<p>达到了玉龙西村的客栈，客栈的主人叫泽西，一坐下他就给我们端上了酥油茶，第一次喝酥油茶，感觉怪怪地，油油地。客栈的女主人也非常热情，帮忙打洗脚水，倒洗澡水，感觉是个非常不错的人。</p>

<p><img src="http://pic.yupoo.com/khotyn/CQkjwr2I/medish.jpg" alt="image" /></p>

<p>这个客栈有电，有热水，中国移动在这儿还偶尔有点信号，感觉又回到了人间。</p>

<p>客栈里面除了我们和泽西的家人，还有三个年轻人，两个男生，一个女生，从和他们交谈的过程中了解到，其中一个男生是清华毕业的学生，在这片区域组织志愿者来教书，这个女生就是他找来的。在这边做教育工作非常不容易，得不到政府、国家的承认，村支书、村长也不支持他们的工作，经常阻扰。从他们口中我们知道了还有一个姓陈的志愿者，瞒着父母跑到这边来，目前在下子梅村，前几天父母已经跑到玉龙西村来打听，刚好我们后面几天就要经过下子梅村，于是他托我们给陈老师带个话，确认陈老师没事儿，然后可以告诉他父母他的近况。</p>

<p>晚上的时候大家商量了明天的行程，照领队的意思我们应该明天上子梅垭口（海拔 4600 米）后就下撤到上子梅村的，但是贡嘎穿越，说白了主要还是希望可以看到贡嘎主峰，如果能够看到日照金山就更好了，最后决定队伍分成两部分，一部分高反不严重的跟着领队小胖在子梅垭口扎营，看日落日出；另一部分跟随领队阿甘下撤到上子梅村。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/03/31/mass/">杂事儿</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-03-31T22:31:00+08:00" pubdate data-updated="true">Mar 31<span>st</span>, 2013</time>
        
         | <a href="/blog/2013/03/31/mass/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>一、坚持</h3>

<p>最近颇为得意的几件事儿，便是年后坚持做了几件事儿，每天背一点英语单词，每天写日记。</p>

<p>背单词我是通过「拓词」这个应用来背的，但是这段时间坚持下来，没有特别好的效果，这个背单词的方法不是正确的方法，背了以后你只能照着「拓词」给出的答案来选，而很难直接给出单词的意思，更不用说对单词的用法进行应用了。另外，「拓词」本身的服务质量也不稳定，计时不准确，App 闪退等问题也比较严重，准备找一种更好的方式来拓展我的词汇量。</p>

<p>写日记我是通过「Day One」这款 App 来记的，我买了 Mac 版和 iOS 版，三个多月使用下来非常棒，「Day One」支持 Markdown，整个应用做的也十分精美，让人看了就有写日记的冲动，特别有意思的时候它有时候会弹出一些话来让你写日记，比如，下面这句：</p>

<blockquote><p>Keep a diary, and someday it&#8217;ll keep you.</p></blockquote>

<p>其实日记是你最私密的东西，在里面，你可以写任何的在其他社交网络上不敢写的东西，可以把你最真实的感情写在里面，让你直面最真实的自己，而当你失落的时候，这些日记就是过去的你，会在背后支持着你。</p>

<p>一直以来，无论是上学的时候，还是工作的时候，总会有不断的计划冒出来，无论当时下多么大的决心，总是到一定阶段的时候放弃了。但是，最近发现，有些决心确实比另外一些更加坚定，持续地更久。其实，我一直以来内心都藏有一种恐惧，害怕自己会变成一个平庸的人，每天上班下班，完成着交给的工作，无所作为，而正是这种恐惧，成为的内心最强大的东西。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/03/23/clojure-game-of-life/">Clojure 学习笔记：生命游戏</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-03-23T16:49:00+08:00" pubdate data-updated="true">Mar 23<span>rd</span>, 2013</time>
        
         | <a href="/blog/2013/03/23/clojure-game-of-life/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>本周继续在看「Clojure Programming」这本书，这本书的第三章讲的是 Clojure 的集合和数据结构，作为这章的结束，作者举了一个「生命游戏」的例子来讲解 Clojure 数据结构的使用，作者一共提供了三种方式来解这个生命游戏，其中前两种方式比较好理解，最后一种方式对我来说理解起来比较困难，不过经过几个小时的推敲，总算是基本搞明白了，这里就将我理解的过程记录一下。</p>

<p>关于什么是「生命游戏」，大家可以直接看维基百科：<a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Game of Life</a>。简单地来说，生命游戏的规则就是在一个二维数组里面，有一些元素是“活着的”，有一些元素是“死亡的”，这个二维数组随着每一代的进化，有些元素会死去，有些元素会活过来，具体变化的规则如下：</p>

<ul>
<li>如果一个元素现在是“活着”的，并且它的邻居里面（周围的 8 个元素）活着的元素的数量少于 2 个，那么这个元素在下一代就会死去。</li>
<li>如果一个元素现在是“活着”的，并且它的邻居里面活着的元素的数量等于 2 个或者 3 个，那么这个元素在下一代会依旧活着。</li>
<li>如果一个元素现在是“活着”的，并且它的邻居里面活着的元素大于 3 个，那么这个元素在下一代周就会死去。</li>
<li>如果一个元素是“死”的，并且它的邻居里面有三个元素是活着的，那么下一代这个元素就会复活。</li>
</ul>


<p>如果我们对这些规则进行简化，就可以得出以下的结论：</p>

<ul>
<li>如果一个元素的邻居有 3 个是活着的，那么无论如何，它在下一代中肯定是活着的。</li>
<li>如果一个元素的邻居有 2 个是活着的，那么下一代中的死活状态和本代是一样的。</li>
<li>如果是其他的情况，那么这个元素在下一代肯定会死去。</li>
</ul>


<p>根据这些规则，「Clojure Programming」这本书给出的代码如下（是的，一共才 11 行代码，不得不感慨 Clojure 真是精简，用 Java 写起来这得多少啊）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="c1">;; 生命游戏</span>
</span><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">neighbours</span>
</span><span class='line'>  <span class="p">[[</span><span class="nv">x</span> <span class="nv">y</span><span class="p">]]</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">for </span><span class="p">[</span><span class="nv">dx</span> <span class="p">[</span><span class="mi">-1</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">]</span> <span class="nv">dy</span> <span class="p">[</span><span class="mi">-1</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">]</span> <span class="ss">:when</span> <span class="p">(</span><span class="nb">not= </span><span class="mi">0</span> <span class="nv">dx</span> <span class="nv">dy</span><span class="p">)]</span>
</span><span class='line'>    <span class="p">[(</span><span class="nb">+ </span><span class="nv">dx</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">dy</span> <span class="nv">y</span><span class="p">)]))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">step</span>
</span><span class='line'>  <span class="s">&quot;Yields the next state of the world&quot;</span>
</span><span class='line'>  <span class="p">[</span><span class="nv">cells</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">set </span><span class="p">(</span><span class="nb">for </span><span class="p">[[</span><span class="nv">loc</span> <span class="nv">n</span><span class="p">]</span> <span class="p">(</span><span class="nf">frequencies</span> <span class="p">(</span><span class="nb">mapcat </span><span class="nv">neighbours</span> <span class="nv">cells</span><span class="p">))</span>
</span><span class='line'>             <span class="ss">:when</span> <span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">and </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nf">cells</span> <span class="nv">loc</span><span class="p">)))]</span>
</span><span class='line'>         <span class="nv">loc</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个源代码的前面一个方法比较简单，就是给定一个元素的座标，计算其邻居的各个元素的座标，主要的代码在第二个方法 step 上。</p>

<p>第二个函数接受的参数是一个当前活着的元素座标的列表，结果是下一代存活的元素的集合。先看第二个函数的 for 循环，这个 for 里面有一个</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nb">mapcat </span><span class="nv">neighbours</span> <span class="nv">cells</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个 <code>mapcat</code> 方法其实是 map 和 concat 两个函数结合，其定义如下：</p>

<blockquote><p>Returns the result of applying concat to the result of applying map
to f and colls.  Thus function f should return a collection.</p></blockquote>

<p>相当于</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nb">concat </span><span class="p">(</span><span class="nb">map </span><span class="nv">neighbours</span> <span class="nv">cells</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这段代码里面这段函数起到的作用就是将当前所有活着的元素的邻居收到一个集合里面。</p>

<p>收集完成以后，函数对这个集合进行了 frequencies 操作，这个 <code>frequencies</code> 就是统计集合内每一个不同的元素出现的数量。最后对 <code>frequencies</code> 的结果进行解构，就得到 for 循环里面的 loc 和 n 的值，其中：loc 就是当前活着的元素的某个邻居的座标，n 就是这个邻居作为邻居出现次数。</p>

<p>但是，这里有一个点需要注意的，如果一个元素 A 是另一个元素 B 的邻居，那么这个元素 A 的邻居也就包含了 B。换句话说，两个元素总是互为邻居的，也就是，n 是这个元素作为邻居出现的次数，<strong>同时也是这个元素周围活着的邻居数量</strong>。</p>

<p>这样，for 循环的后面还有的 <code>:when</code> 就可以根据规则对 n 的值进行判断了：</p>

<ul>
<li>如果 n 为 3，无论如何这个元素在下一代都会活着，所以这个元素的座标就作为结果返回了（就是最后的 <code>loc</code> 那段代码）。</li>
<li>如果 n 为 2，那么需要进行进一步的判断，如果当前元素在 <code>cells</code> 中，也就是说当前元素原来是活着的，根据规则，它下一代依旧会活着，它的座标也会被返回。</li>
</ul>


<p>最后，所有符合上面的条件的元素都会被返回，这个函数最后就返回了下一代中所有的存活的元素的座标了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/03/17/learning-clojure-partone/">Clojure 学习笔记：开始</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-03-17T20:44:00+08:00" pubdate data-updated="true">Mar 17<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/03/17/learning-clojure-partone/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>一、 为什么学 Clojure</h3>

<p>Clojure 一直是我想去学习的一门语言，从去年开始就想学，但是我一直忍着没学，没学的原因一方面是想看一看自己是不是三分钟热度，过了一段时间就不再对它感兴趣了。另一方面，我更想去多学一些计算机底层的技术，因为我自认为基础并不太好，未来会成为个人发展的一个障碍。</p>

<p>但是，从现在看来，我似乎对 Clojure 并不是脑子一热就想去学，而有一些更深层的原因。我想学 Clojure 一个主要的原因是因为最近一段时间一直在思考语言的抽象维度，表达能力的问题，对这个问题我虽然有一些感觉，但是因为了解的语言非常有限，所以一直都没有抓到问题的本质，找不到问题的答案是什么，而多了解一门不同类型的语言或许可以在一定程度上帮助我思考这个问题，如果这门语言和 Java 越不同，能给我带来的思维的转换就越大，显然 Lisp 会是很好的选择。而 Clojure 正是基于 JVM 的一种 Lisp 方言，对做 Java 开发的我来说再好不过。</p>

<h3>二、Clojure 是一门什么样的语言</h3>

<p>面对这个问题，我的脑子中一下子塞入了各种名词：</p>

<ul>
<li>不变量</li>
<li>函数式编程</li>
<li>S 表达式</li>
<li>一堆括号</li>
<li>宏</li>
</ul>


<p>现在对 Clojure 的认识还很模糊，这个问题我希望能够一直带在整个学习过程中，希望在经过一段时间的学习以后可以回答这个问题。</p>

<h3>三、环境安装</h3>

<p>在 Mac 下可以直接通过 brew 来安装：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>brew install clojure</span></code></pre></td></tr></table></div></figure>


<p>Clojure 官网也提供了其他的安装方式：<a href="http://clojure.org/getting_started">http://clojure.org/getting_started</a></p>

<p>编辑器我选择是 Intellij IDEA，安装上一个 La Clojure 的插件即可，这个插件提供了代码高亮、格式化等功能，并且针对 Clojure 括号略多的情况，给括号提供了彩虹色的高亮，非常贴心。另外 La Clojure 内置的 REPL 在语法高亮、光标的移动方面都比 Clojure 自带的要好。</p>

<h3>四、学习资料</h3>

<p>关于 Clojure 的书比较著名的有三本：</p>

<ul>
<li><a href="http://book.douban.com/subject/4743790/">The Joy of Clojure</a></li>
<li><a href="http://book.douban.com/subject/7915128/">Programming Clojure</a></li>
<li><a href="http://book.douban.com/subject/6715378/">Clojure Programming</a></li>
</ul>


<p>目前这三本书中 The Joy of Clojure 正在翻译中，Programming Clojure 和 Clojure Programming 已经翻译好，可以在各大网站上预订了，想看中文版的朋友可以考虑去买纸质书。</p>

<p>我选择了 Clojure Programming 这本书，没什么原因，刚好之前下载了这本书的英文版，看着看着就一直再看了。</p>

<h3>五、下一篇</h3>

<p>这第一篇笔记没有什么关于 Clojure 的具体内容，主要作用在于提醒自己学习要不忘初衷，下一篇中我会开始整理出一些具体内容出来，敬请期待。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/3/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/09/14/spring-tx-propagation/">Spring 事务的传播特性</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/09/05/thanks-my-friend/">谢谢我的小伙伴们</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/09/03/crush/">Crush</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/08/03/dumping-class-from-jvm/">从 JVM 中 dump class 的几种方法</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/07/30/sed-part-two/">「Sed & Awk」阅读笔记之 Sed 高级命令</a>
      </li>
    
  </ul>
</section>






  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - khotyn -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'khotynblog';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
